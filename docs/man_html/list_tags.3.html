<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>FILESTRUCT(3NEMO) manual page</title>
</head>
<body bgcolor='white'>
HTML automatically generated with <A HREF=http://manpages.ubuntu.com/manpages/bionic/man1/rman.1.html>rman</A><br>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
filestruct - primitives for structured binary file I/O 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<br>
<pre>#include &lt;stdinc.h&gt;
#include &lt;filestruct.h&gt;
bool get_tag_ok(str, tag)
void get_data(str, tag, typ, dat, dimN, ..., dim1, 0)
void get_data_coerced(str, tag, typ, dat, dimN, ..., dim1, 0)
string get_string(str, tag)
void get_set(str, tag)
void get_tes(str, tag)
void put_data(str, tag, typ, dat, dimN, ..., dim1, 0)
void put_string(str, tag, msg)
void put_set(str, tag)
void put_tes(str, tag)

void get_data_set(str, tag, typ, dat, dimN, ..., dim1, 0)
void get_data_ran(str, tag, dat, offset, length)
void get_data_blocked(str, tag, dat, length)
void get_data_tes(str, tag)
void put_data_set(str, tag, typ, dat, dimN, ..., dim1, 0)
void put_data_ran(str, tag, dat, offset, length)
void put_data_blocked(str, tag, dat, length)
void put_data_tes(str, tag)

string get_type(str, tag)
int *get_dims(str, tag)
int get_dlen(str, tag)

void strclose(str)
bool qsf(str)

stream str;
string tag;
int typ;
byte *dat;
int dimN, ..., dim1;
string msg;
int offset, length
</pre>
<h2><a name='sect2' href='#toc2'>Description</a></h2>
These routines provide a simple yet reasonably general mechanism
for the structured input and output of binary data.  A structured binary
file may be viewed as a sequence of tagged data items (very much like the
more modern XLM files); special symbols are introduced to group items hierarchically
into sets.  Data items are typically scalar values or homogeneous arrays
constructed from the elementary C data types: <b>char, short, int, long, float,
double</b>. <i>filestruct.h</i> defines the following symbolic names for these types:

<dl>

<dt><b>CharType</b> </dt>
<dd>standard C characters, assumed printable. </dd>

<dt><b>ByteType</b> </dt>
<dd>like C characters,
but unsigned and unprintable. </dd>

<dt><b>AnyType</b> </dt>
<dd>anything at all; see below. </dd>

<dt><b>ShortType</b>
</dt>
<dd>standard C short integers. </dd>

<dt><b>IntType</b> </dt>
<dd>standard C integers. </dd>

<dt><b>LongType</b> </dt>
<dd>standard
C long integers. </dd>

<dt><b>HalfpType</b> </dt>
<dd>16 bit floating point half precision (non-standard,
cf. EXR) </dd>

<dt><b>FloatType</b> </dt>
<dd>standard C floating point. </dd>

<dt><b>DoubleType</b> </dt>
<dd>standard C double-precision.
</dd>
</dl>
<p>
The first three types are all synonyms for <b>CharType</b>, but the meanings conveyed
are quite different.  <b>CharType</b> is reserved for strings of legible characters,
while <b>ByteType</b> identifies data in 8-bit binary chunks.  <b>AnyType</b>, while operationally
identical, implies that data (typically in an array) may not naturally
divide on 8-bit boundaries; this type currently provides an escape hatch
for structure I/O (see the example below). 
<p> <i>get_tag_ok(str, tag)</i> is used
to determine if a subsequent <i>get_data()</i>, <i>get_string()</i>, or <i>get_set()</i> call
will succeed in finding an item named <i>tag</i> in the structured binary input
stream <i>str</i>.  The algorithm used to determine this depends on whether the
structured input point is at top level or within a set. At top level, the
next item must match the specified <i>tag</i>. Within a set, the input point is
effectively rewound to the first item of the set, and the entire set is
scanned for the <i>tag</i>. <i>get_tag_ok()</i> returns <b>FALSE</b> on end of file. 
<p> <i>get_data(str,
tag, typ, dat, dimN, ..., dim1, 0)</i> transfers data from a structured binary
input stream <i>str</i> to a scalar or homogeneous array at address <i>dat</i>.  First
an item named <i>tag</i> is found with the algorithm described above.  The type
of the item is checked against <i>typ</i>, and the dimensions (if any) are checked
against arguments <i>dimN, ..., dim1</i>.  If they match, the item data is copied
to the specified address. 
<p> <i>get_data_coerced(str, tag, typ, dat, dimN, ...,
dim1, 0)</i> performs the same function as <i>get_data()</i> except that the types
of the item may be <i>FloatType</i> and the type specified by the parameter <i>typ</i>
may be <i>DoubleType</i>  or the other way around. If <i>typ</i> matches the type of the
item, this function is identical to <i>get_data()</i>; if a conversion other than
Float-&gt;Double or Double-&gt;Float is attempted, an error is signaled. 
<p> <i>get_string(str,
tag)</i> searches as above for an item named <i>tag</i>, which must contain a null-terminated
array of characters. The data is copied to space allocated using <a href='malloc.3.html'><i>malloc</i>(3)</a>

and a pointer is returned. 
<p> <i>get_set(str, tag)</i> searches as above for a set
named <i>tag</i> (in fact, the <i>tag</i> is carried by a special symbol used to mark
the start of the set).  The contents of this set are then taken as the scope
of subsequent <i>get_tag_ok()</i>, <i>get_data()</i>, <i>get_string()</i> and <i>get_set()</i> calls.

<p> <i>get_tes(str, tag)</i> terminates the scan of the current input set, and returns
to the scope which was in effect before the set was accessed.  If <i>tag</i> is
not NULL, it must match the tag of the corresponding <i>get_set()</i> call.  When
input is from the top level, the input pointer is left before the next
item in the input stream. (Note: <i>tes</i> is set backwards). 
<p> <i>put_data(str, tag,
typ, dat, dimN, ..., dim1, 0)</i> is effectively the inverse of <i>get_data()</i> above:
the data pointed to by <i>dat</i>, which is of type <i>typ</i> and dimensions <i>dimN, ...,
dim1</i>, is emitted to the structured output stream <i>str</i> as an item named <i>tag</i>.

<p> <i>put_string(str, tag, msg)</i> is the inverse of <i>get_string()</i> above. 
<p> <i>put_set(str,
tag)</i> begins the output of a set named <i>tag</i>. The contents of the set are supplied
by subsequent calls to <i>put_data()</i>, <i>put_string()</i>, and <i>put_set()</i>. 
<p> <i>put_tes(str,
tag)</i> terminates the output of a set. 
<p> <i>strclose(str)</i> is the preferred way
to close binary streams used in the above operations; it need not be called
unless the stream must be explicitly closed (for example, for later reuse).
In case the stream was opened as a special one (e.g. a scratch stream, see
 <a href='stropen.3.html'><i>stropen(3NEMO)</i></a>
), <i>strclose</i> is the only means to properly clean up. 
<p> <i>qsf(str)</i>
queries if an input stream is a binary structured one. Since this requires
data to be read (which may be needed later on), this function cannot be
used with pipes. <i>qsf</i> always returns FALSE in this case. Also, it is left
to the application programmer to properly place the filepointer (<a href='rewind.3.html'><i>rewind(3)</i></a>
)
in case that stream has to be used for input. 
<p> <i>get_data_set</i> and get_data_tes
bracket random data access, which is achieved by <i>get_data_ran</i>. <i>offset</i> and
<i>length</i> are both in units of the item-length. They have a pipe-safe interface
called <i>get_data_blocked</i>, where the I/O must occur sequentially. 
<p> <i>get_type</i>,
 <i>get_dims</i>,  and <i>get_dlen</i> return the type,  dimension array (allocated and
zero terminated!),  and data-length in bytes for the whole item. These routines
should be rarely needed by programmers though. 
<h2><a name='sect3' href='#toc3'>Examples</a></h2>
The following code
fragment reads and later writes some data to structured binary files. <br>
<pre>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream instr, outstr;
&nbsp;&nbsp;&nbsp;&nbsp;int nobj;
&nbsp;&nbsp;&nbsp;&nbsp;double time, mass[4096], phase[4096][2][3];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;get_set(instr, "SnapShot");
&nbsp;&nbsp;&nbsp;&nbsp;get_set(instr, "Parameters");
&nbsp;&nbsp;&nbsp;&nbsp;get_data(instr, "Time", DoubleType, &amp;time, 0);
&nbsp;&nbsp;&nbsp;&nbsp;get_data(instr, "Nobj", IntType, &amp;nobj, 0);
&nbsp;&nbsp;&nbsp;&nbsp;get_tes(instr,"Parameters");
&nbsp;&nbsp;&nbsp;&nbsp;get_set(instr, "Particles");
&nbsp;&nbsp;&nbsp;&nbsp;if (get_tag_ok(instr, "Mass"))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get_data(instr, "Mass", DoubleType, mass, nobj, 0);
&nbsp;&nbsp;&nbsp;&nbsp;get_data(instr, "PhaseSpace", DoubleType, phase,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      nobj, 2, 3, 0);
&nbsp;&nbsp;&nbsp;&nbsp;get_tes(instr, "Particles");
&nbsp;&nbsp;&nbsp;&nbsp;get_tes(instr, "SnapShot");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;put_set(outstr, "SnapShot");
&nbsp;&nbsp;&nbsp;&nbsp;put_set(outstr, "Parameters");
&nbsp;&nbsp;&nbsp;&nbsp;put_data(outstr, "Time", DoubleType, &amp;time, 0);
&nbsp;&nbsp;&nbsp;&nbsp;put_data(outstr, "Nobj", IntType, &amp;nobj, 0);
&nbsp;&nbsp;&nbsp;&nbsp;put_tes(outstr, "Parameters");
&nbsp;&nbsp;&nbsp;&nbsp;put_set(outstr, "Particles");
&nbsp;&nbsp;&nbsp;&nbsp;put_data(outstr, "Mass", DoubleType, mass, nobj, 0);
&nbsp;&nbsp;&nbsp;&nbsp;put_data(outstr, "PhaseSpace", DoubleType, phase,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       nobj, 2, 3, 0);
&nbsp;&nbsp;&nbsp;&nbsp;put_tes(outstr, "Particles");
&nbsp;&nbsp;&nbsp;&nbsp;put_tes(outstr, "SnapShot");

</pre></b>&nbsp;&nbsp;&nbsp;&nbsp;Notes: the first two calls to <i>get_data()</i> and <i>put_data()</i> illustrate the
I/O of scalar data: although no dimensions are listed, the terminating
<b>0</b> (zero) must appear in the arg list.  Later calls show how arrays are specified.
 The <b>Mass</b> item will only be input if it appears in the <b>Particles</b> set. 
<p> Structures
which do not contain pointer data can be handled using the <b>AnyType</b>, but
with somewhat limited functionality: a structure of type <b>foo</b> is treated
as an array of <b>sizeof(foo)</b> objects of type <b>AnyType</b>.  This means, alas, that
the contents of structures are hidden to utilities like <a href='tsf.1.html'><i>tsf</i>(1)</a>
. The following
example shows how to handle structures: <br>
<pre>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct foo {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int erupt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char actor;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double trouble;
&nbsp;&nbsp;&nbsp;&nbsp;} footab[64];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;get_data(instr, "FooTab", AnyType, footab,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       64, sizeof(struct foo), 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;put_data(outstr, "FooTab", AnyType, footab,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       64, sizeof(struct foo), 0);

</pre>
<h2><a name='sect4' href='#toc4'>&nbsp;&nbsp;&nbsp;&nbsp;Diagnostics</a></h2>
Exceptional conditions (eg, unexpected EOF), invalid arguments
(eg, types out of range) and low-level catastrophies (eg, running out of
memory) generate messages via <a href='error.3.html'><i>error</i>(3)</a>
, which will, in general, return
the program to the operating system. This error-checking is implemented with
the goal of freeing applications programmers from the responsibility of
checking for I/O errors other than end-of-file. 
<h2><a name='sect5' href='#toc5'>Notes</a></h2>
The library will delay
reading large data-items in memory and only store a pointer to their location
until it is really needed via one of the get_data() routines. 
<h2><a name='sect6' href='#toc6'>Caveats</a></h2>
Whenever
pipes are used, all data is read into memory, as opposed to being deferred
for input. This may lead to large memory consuption.  <p>
random access can currently
only take place in one item 
<h2><a name='sect7' href='#toc7'>Author</a></h2>
Joshua E. Barnes, Lyman P. Hurd, Peter
Teuben 
<h2><a name='sect8' href='#toc8'>See Also</a></h2>
<a href='filestruct.5.html'>filestruct(5NEMO)</a>
, <i>NEMO Users/Programmers Guide</i> <p>
<a href='http://www.openexr.com/about.html#features'>http://www.openexr.com/about.html#features</a>

 (half precision floating point) 
<h2><a name='sect9' href='#toc9'>Update History</a></h2>
<br>
<pre>4-Apr-87<tt> </tt>&nbsp;<tt> </tt>&nbsp;original implementation<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;JEB
30-Aug-87<tt> </tt>&nbsp;<tt> </tt>&nbsp;type coersion, deferred input<tt> </tt>&nbsp;<tt> </tt>&nbsp;LPH
16-Apr-88<tt> </tt>&nbsp;<tt> </tt>&nbsp;new types, operators, etc<tt> </tt>&nbsp;<tt> </tt>&nbsp;JEB
16-May-92<tt> </tt>&nbsp;<tt> </tt>&nbsp;random access to data   <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
5-mar-94<tt> </tt>&nbsp;<tt> </tt>&nbsp;documented qsf          <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
2-jun-05<tt> </tt>&nbsp;<tt> </tt>&nbsp;added blocked I/O<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
</pre> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Examples</a></li>
<li><a name='toc4' href='#sect4'>Diagnostics</a></li>
<li><a name='toc5' href='#sect5'>Notes</a></li>
<li><a name='toc6' href='#sect6'>Caveats</a></li>
<li><a name='toc7' href='#sect7'>Author</a></li>
<li><a name='toc8' href='#sect8'>See Also</a></li>
<li><a name='toc9' href='#sect9'>Update History</a></li>
</ul>
</body>
</html>
