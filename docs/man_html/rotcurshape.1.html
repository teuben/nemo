<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>ROTCURSHAPE(1NEMO) manual page</title>
</head>
<body bgcolor='white'>
HTML automatically generated with <A HREF=http://manpages.ubuntu.com/manpages/bionic/man1/rman.1.html>rman</A><br>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
rotcurshape - fit parameters to a velocity field using shaped rotation
curves in a co-planar disk 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>rotcurshape in=</b>velfie [parameters=values
...] 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
<i>rotcurshape</i> derives the rotation curve and kinematic parameters
from an observed velocity field of a coplanar galactic disk by fitting
a (set of) rotation curve shape(s). Instead of dividing the galactic disk
in a set of rings (see <a href='rotcur.1.html'><i>rotcur(1NEMO)</i></a>
) it fits the shape of the rotation
curve in an annulus of a planar disk. This is particularly useful for low
inclination galaxies and/or for central regions of a galaxy where normally
the rotation curve would vary accross the ring/annulus. <p>
Much like <i>rotcur</i>,
this program does a non-linear least-squares-fit to the function: <p>
  <br>
<pre>         v(x,y) = VSYS + VROT(r) * cos(theta) * sin(INC)
where again
                      - (x-XPOS) * sin(PA) + (y-YPOS) * cos(PA) 
          cos(theta) = -----------------------------------------
                                       r
</pre>and where the radius <i>r</i> is measured in the plane of the galaxy: <p>
The parameterized
 rotation curve VROT(r;p1,p2,...pN) can be selected from a number of predefined
shapes or dynamically loaded from a C-coded routine (see ROTCUR FUNCTIONS
below). Up to 5 functions can be added in quadrature (but be aware of degeneracies)
<p>
In the above formula <i>v(x,y)</i> denotes the radial velocity at rectangular
sky coordinates <i>x</i> and <i>y</i>, <i>VSYS</i> the systemic  velocity, <i>VROT</i> the rotational
velocity, <i>INC</i> the inclination angle and <i>theta</i> the  azimuthal distance from
the major axis in the plane of the galaxy.   In itself, <i>theta</i> is a function
of the inclination (<i>INC</i>) and the  position angle (<i>PA</i>) of the major axis.
<i>XPOS</i> and <i>YPOS</i> denote the position of the rotation center in pixels w.r.t.
0,0 being the lower left corner of the map (note that MIRIAD and GIPSY
all have different conventions where 0,0 is).  <i>rotcurshape</i><br>
 can fit the 5 geometric parameters <i>VSYS</i>, <i>INC</i>, <i>PA</i>, <i>XPOS</i> and <i>YPOS</i>,  though
any combination of them can be fixed (see <b>fixed=</b>). The position angle <i>PA</i>
of the major axis is defined as the angle, taken in anti-clockwise direction
between the north direction on the &lsquo;&lsquo;sky&rsquo;&rsquo; and the major axis of the receding
half (positive  radial velocity) of the galaxy.  <p>
Values equal the undefined
value (currently 0.0) are ignored in the fit. See <a href='ccdmath.1.html'><i>ccdmath(1NEMO)</i></a>
 or <a href='fitsccd.1.html'><i>fitsccd(1NEMO)</i></a>

on how to create a velocity field with such undefined values (see also
EXAMPLES below). 
<h2><a name='sect3' href='#toc3'>Parameters</a></h2>
The following parameters are known (those with
** are still here since we cloned this program off rotcur, but are likely
to be slashed or (re)implemented): 
<dl>

<dt><b>in=</b><i>v_image|xyv_tab|rv_tab</i> </dt>
<dd>Input velocity
field map, normally in <a href='image.5.html'><i>image(5NEMO)</i></a>
 format. Input data can also be a table,
see <b>imagemode=</b> and <b>rotcurmode=</b> below how to control the input table. No
default. </dd>

<dt><b>radii=</b><i>r0,r1</i> </dt>
<dd>Inner and outer radius of the disk to fit (in arcsec).
For images, the <b>units=</b> keyword can be used to scale your physical units
in the header to &lsquo;&lsquo;human readable&rsquo;&rsquo; units (arcsec). By default the whole disk
will be used. </dd>

<dt><b>pa=</b><i>pa</i> </dt>
<dd>Kinematic position angle (in degrees) of the disk (i.e.
receding side). Angles can be 0..360 or -180..180. </dd>

<dt><b>inc=</b><i>inc</i> </dt>
<dd>Inclination (degrees)
of the disk. Angles can be 0..90. </dd>

<dt><b>vsys=</b><i>v0</i> </dt>
<dd>Systemic velocity. </dd>

<dt><b>center=</b><i>x0,y0</i> </dt>
<dd>Rotation
center (grid units w.r.t. lower left corner being 0,0 for NEMO maps). Two numbers
are required. For tabular input the units must be the same as those used
in the table. Default: center of map. </dd>

<dt><b>frang=</b> </dt>
<dd>free angle around minor axis
(degrees), in the plane of the galaxy, from which data is excluded from
the fit (thus the total cone size of ignored data around the minor axis
is 2*<b>frang</b>) [Default: <b>0.0</b>]. </dd>

<dt><b>side=</b> </dt>
<dd>Choose the side of the galaxy to fit the
velocity field to. Valid options are <b>receding</b>, <b>approaching</b>  or <b>both</b> side(s).
[Default: <b>both</b>]. </dd>

<dt><b>weight=</b> </dt>
<dd>Choice of geometric weighting function with which
points are weighed into the least squares solution as a function of galactic
angle away from the major axis. Valid options are: <b>uniform</b>, <b>cosine</b>, and
<b>cos-squared</b>.  If a density is given (see <b>dens=</b>), the weight function is multiplied
by this geometric weight factor. [Default: <b>uniform</b>]. </dd>

<dt><b>fixed=</b> </dt>
<dd>List of disk
geometry parameters to be kept fixed during the fit. Choose any of the following:
<b>vsys,pa,inc,xpos,ypos</b>, although <b>all</b> can also be use to fix all geometric
parameters. [Default: none, i.e. all parameters free] </dd>

<dt>** <b>ellips=</b> </dt>
<dd>The names
of two parameters for which to calculate an error ellips.  (see <b>fixed=</b>).
For the two parameters it shows the major and minor axis, position angle
of the one sigma deviation ellipse. [Default: not used] </dd>

<dt>** <b>beam=</b> </dt>
<dd>The beam
size (FWHM) for beam correction. One or two numbers required. Currently these
are only used to correct error bars for the number of independant points
per beam. If not given, each point is assumed independant. [no correction].
** See CAVEATS below ** </dd>

<dt><b>dens=</b><i>image_den</i> </dt>
<dd>Image containing the density. Currently
only used as an additional weight factor. If a map of velocity dispersions
would be available, a density map would need to be contstructed from its
inverse square, i.e. dens=1/sigma^2. Default: not used. </dd>

<dt><b>tab=</b> </dt>
<dd>If specified, this
output table is used in <i>append</i> mode! **deprecated** [Default: not used].
</dd>

<dt><b>resid=</b> </dt>
<dd>Residuals (OBS-FIT) if specified. If the input file was a table (see
also <b>imagemode=</b>), this will contain a listing of X,  Y, Velocity and Residual
Velocities in the disk, else it will be an <a href='image.5.html'><i>image(5NEMO)</i></a>
 of the residuals.
Note for <b>nsigma&gt;0</b> the residual map will be two maps, and you will need <a href='csf.1.html'><i>csf(1NEMO)</i></a>

to get access to the 2nd (supposedly improved) residual map. [Default: not
used]. </dd>

<dt><b>fit=t|f</b> </dt>
<dd>Controls if the residual output map (<b>resid=</b> should contain
the residuals [the default], or the fitted map. If the fit is selected,
the mask values are ignored and the map is filled with the fitted values.
[Default: <b>f</b>] </dd>

<dt><b>tol=</b> </dt>
<dd>Tolerance for convergence of <i>nllsqfit</i> [Default: <b>0.001</b>].
</dd>

<dt><b>lab=</b> </dt>
<dd>Mixing parameter for <i>nllsqfit</i> [Default: <b>0.001</b>] </dd>

<dt><b>itmax=</b> </dt>
<dd>Maximum number
of allowed <i>nllsqfit</i> iterations [Default: <b>50</b>] </dd>

<dt><b>units=</b> </dt>
<dd>Units of input axes
for radius and velocity. Valid options are <b>deg, arcmin, arcsec, rad</b> for
radius. A numeric value can also be given, in which case your image pixel
separation from the image header is multiplied by this number to get to
the &lsquo;&lsquo;arcsec&rsquo;&rsquo; that will be quoted in the tables. The units for velocity can
only be numeric, and will be the factor by which the velocities in the
map are multiplied. For tabular input the spatial scaling factor is ignored,
since all spatial coordinates need to be in the same coordinate system.
[Default: <b>deg</b>] </dd>

<dt><b>blank=</b> </dt>
<dd>Value of the blank pixel that needs to be ignored.
[Default: <b>0.0</b>]. </dd>

<dt><b>nsigma=</b> </dt>
<dd>Reject outlier points will fall outside nsigma times
the dispersion  away from the mean velocity in the disk. By default, it
will not reject any outliers. Use with care, only useful if close enough
to a solution and just a few outliers need to be removed.  </dd>

<dt><b>imagemode=t|f</b>
</dt>
<dd>Image input file mode? By default the input file is an image, alternatively
a simple ascii table with X and Y positions in columns 1 and 2, and radial
velocities in column 3 can be used by the <i>xyv_tab</i> (see <b>in=</b>). The units of
the spatial coordinates now need to be the same as <b>center=</b>, and the <b>units=</b>
factor is ignored in this case. Future expansion will likely allow weight
factors to be added in other columns. [Default: t] </dd>

<dt><b>rotcurmode=t|f</b> </dt>
<dd>Input table
is a rotation curve (R,V) in columns 1 and 2. Radius is allowed to be negative,
as this option is implemted as a special version of XYV where we fix XPOS=0,INC=30,PA=0.
The center can therefore be fitted via YPOS. Note that <a href='tabnllsqfit.1.html'><i>tabnllsqfit(1NEMO)</i></a>

is also quite efficient to use, except the rotation curve functions would
need to be re-written in their function interface. See also func_rotcur.c
for a useful helper routine. </dd>

<dt><b>load=</b><i>so_file</i> </dt>
<dd>Name of a shared object file containing
rotation curve(s). The function names  must be <b>rotcur_</b><i>name</i>, where <i>name</i> is
the identifier name of the rotation curve used in the subsquent <b>rotcur#=</b>
keywords. </dd>

<dt><b>rotcur1=</b><i>name1,p1,p2,...pN,m1,m2,..mN</i> </dt>
<dd>Name of first rotation curve,
followed by the initial estimates of its parameters (you do need to know
how many there are), followed by an equal number of 1s (free) and 0s (fixed)
to denote which parameters are free or fixed during the fitting process.
 </dd>

<dt><b>rotcur2=</b><i>name2...</i> </dt>
<dd>see rotcur1 </dd>

<dt><b>rotcur3=</b><i>name3...</i> </dt>
<dd>see rotcur1 </dd>

<dt><b>rotcur4=</b><i>name4...</i> </dt>
<dd>see
rotcur1 </dd>

<dt><b>rotcur5=</b><i>name5...</i> </dt>
<dd>see rotcur1.  The final composite rotation curve will
be the sum (in quadrature) of up to these 5 components. 
<p> </dd>
</dl>

<h2><a name='sect4' href='#toc4'>Rotcur Functions</a></h2>
A
<i>rotcur</i> function needs to provide a routine that returns a rotation curve,
as well as all of its partial derivates w.r.t. the parameters. Most rotation
curve shapes have two parameters, a velocity and a radial scale parameter,
and they are usually the first and second parameter. Note that the user
needs to know how many parameters a <i>rotcur</i> function has. Apart from a number
of pre-defined ones, the user can write his/her own in the C language and
loaded via the <b>load=</b> keyword (see also  <a href='loadobj.3.html'><i>loadobj(3NEMO)</i></a>
. <p>
Here are two examples,
a simple linear rotation curve with one parameter, and a   slightly more
involved Plummer disk/sphere rotation curve with two parameters: <br>
<pre>#include &lt;nemo.h&gt;
real rotcur_linear(real r, int n, real *p, real *d)
{
  d[0] = r;
  return p[0] * r;
}
real rotcur_plummer(real r, int np, real *p, real *d)
{
  real x = radius/p[1];
  real y = pow(1+x*x,-0.75);
  d[0] = y;
  d[1] = -x*p[0]/p[1]*(1-x*x/2)/(1+x*x)/y;
  return p[0] * x * y;
}
</pre><p>
Here is a list of the builtin rotation curves, where x=r/a is the dimensionless
radius: <br>
<pre>Name:<tt> </tt>&nbsp;<tt> </tt>&nbsp;Parameters:<tt> </tt>&nbsp;<tt> </tt>&nbsp;Formula:<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Comments:
-----<tt> </tt>&nbsp;<tt> </tt>&nbsp;-----------<tt> </tt>&nbsp;<tt> </tt>&nbsp;--------<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;---------
linear<tt> </tt>&nbsp;<tt> </tt>&nbsp;omega   <tt> </tt>&nbsp;<tt> </tt>&nbsp;v=omega*r<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;-
flat<tt> </tt>&nbsp;<tt> </tt>&nbsp;v0       <tt> </tt>&nbsp;<tt> </tt>&nbsp;v=v0<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;should return rotcur solution
plummer<tt> </tt>&nbsp;<tt> </tt>&nbsp;v0,a    <tt> </tt>&nbsp;<tt> </tt>&nbsp;v=v0*x/(1+x^2)^(3/4)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;-
core1<tt> </tt>&nbsp;<tt> </tt>&nbsp;v0,a      <tt> </tt>&nbsp;<tt> </tt>&nbsp;v=v0*x/(1+x)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;-
core2<tt> </tt>&nbsp;<tt> </tt>&nbsp;v0,a    <tt> </tt>&nbsp;<tt> </tt>&nbsp;v=v0*x/(1+x^2)^(1/2)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;-
core<tt> </tt>&nbsp;<tt> </tt>&nbsp;v0,a,c  <tt> </tt>&nbsp;<tt> </tt>&nbsp;v=v0*x/(1+x^c)^(1/c)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;-
arctan<tt> </tt>&nbsp;<tt> </tt>&nbsp;c0,a<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;v=2*v0/pi*arctan(x)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;-
poly<tt> </tt>&nbsp;<tt> </tt>&nbsp;v0,a,p2,.. <tt> </tt>&nbsp;<tt> </tt>&nbsp;v=v0*(x+p2*x^2+p3*x^3+.....pN*x^N) <tt> </tt>&nbsp;<tt> </tt>&nbsp;a needs to be fixed !
iso<tt> </tt>&nbsp;<tt> </tt>&nbsp;v0,a    <tt> </tt>&nbsp;<tt> </tt>&nbsp;v=v0*sqrt(1-atan(x)/x)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;-
exp <tt> </tt>&nbsp;<tt> </tt>&nbsp;v0,a    <tt> </tt>&nbsp;<tt> </tt>&nbsp;v=v0*(1-exp(-x))                 <tt> </tt>&nbsp;<tt> </tt>&nbsp;-
nfw<tt> </tt>&nbsp;<tt> </tt>&nbsp;v0,a,c  <tt> </tt>&nbsp;<tt> </tt>&nbsp;v=v0*sqrt((ln(1+cx)-cx/(1+cx))/x/(ln(1+c)-c/(1+c)))<tt> </tt>&nbsp;<tt> </tt>&nbsp;needs a fixed
&rsquo;c&rsquo; <tt> </tt>&nbsp;<tt> </tt>&nbsp;
power<tt> </tt>&nbsp;<tt> </tt>&nbsp;v0,a,p  <tt> </tt>&nbsp;<tt> </tt>&nbsp;v=v0*x^p                         <tt> </tt>&nbsp;<tt> </tt>&nbsp;a needs to be fixed (scale
free)!
</pre>
<h2><a name='sect5' href='#toc5'>Example</a></h2>
First an example of creating a synthetic velocity field with <a href='ccdvel.1.html'><i>ccdvel(1NEMO)</i></a>
,
and analysing it with  rotcurshape, by using a simple rotation curve  entered
by a sneaky construction in shell variables <b>$r</b> and  <b>$v</b>. The shape function
is a <b>core1</b> with amplitude 200 and core radius 20: <br>
<pre>    % set r=&lsquo;nemoinp 0:60&lsquo;
    % set v=&lsquo;nemoinp 0:60 | tabmath - - "100*%1/(20+%1)" all&lsquo;
    % ccdvel out=map1.vel rad="$r" vrot="$v" pa=30 inc=60
    % rotcurshape in=map1.vel radii=0,60 pa=30 inc=60 vsys=0 units=arcsec,1
\
         rotcur1=core1,100,20,1,1 tab=-
VSYS: 2.36846e-18 0.00110072
XPOS: 63.5 0.000759475
YPOS: 63.5 0.00100543
PA:   30 0.0010416
INC:  60.0001 0.00229122
P1:  100.392 0.00757645
P2:  20.2883 0.0045192
NPT:  5658
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;(this is also the Testfile version)
</pre>The reason why the error bars are not exactly zero is because  ccdvel interpolates
from the (r,v) table, and the finite pixel sizes. <p>
Here is an example to
write your own C code with a rotation curve, and load it in during runtime:
(examples are in $NEMO/src/image/rotcur/shape): <br>
<pre>    % cat mylinear.c
    #include &lt;nemo.h&gt;
    real rotcur_linear(real r, int n, real *p, real *d)
    {<tt> </tt>&nbsp;<tt> </tt>&nbsp;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;d[0] = r;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;return p[0] * r;
    }
    % bake mylinear.so
    % rotcurshape in=map1.vel radii=0,10 load=mylinear.so rotcur1=linear,10,1
</pre><p>
Here is a contrived example of creating a velocity model field with rotcurshape
by supplying a zero map, fixing all parameters, and computing the residual
velocity field (OBS-FIT). Of course you will get -1 times the velocity field,
but still. It is an alternative to <a href='ccdvel.1.html'><i>ccdvel(1NEMO)</i></a>
 <br>
<pre>    % ccdmath out=map0.vel fie=0 size=128,128
    % rotcurshape map0.vel 0,40 30 45 0 blank=-999 resid=map.vel \
<tt> </tt>&nbsp;<tt> </tt>&nbsp;rotcur1=plummer,200,10,0,0 fixed=all units=arcsec,1 
</pre><p>
When <b>nsigma&gt;0</b> is used to find an improved solution, the residual map now
contains 2 maps, and it is the 2nd map which contains the supposed improved
map. Here is an example how to extract and display that 2nd map using <a href='csf.1.html'><i>csf(1NEMO)</i></a>

<br>
<pre>    % rotcurshape map0.vel 0,40 30 45 0 blank=-999 resid=map.vel \
<tt> </tt>&nbsp;<tt> </tt>&nbsp;rotcur1=plummer,200,10,0,0 fixed=all units=arcsec,1 nsigma=2
    % csf map.vel map2.vel item=Image select=2
    % nds9 map2.vel
</pre>
<h2><a name='sect6' href='#toc6'>Files</a></h2>
<br>
<pre>func_rotcur.c<tt> </tt>&nbsp;<tt> </tt>&nbsp;helper routine for tabnllsqfit to use rotcur functions
$NEMO/src/image/rotcur/shape/<tt> </tt>&nbsp;<tt> </tt>&nbsp;directory with other example shape functions
</pre><br>
<pre>CaveatParameters and fix/free masks to rotation curve parameters should
be all set, in order for the respective routines to figure out the correct
number of parameters. For example, the poly rotation curve can only determine
the correct order of the polynomial by counting the number of arguments
given in that option, e.g. rotcur1=poly,100,10,2,2,1,1,1,1  would use a 3th
order polynomial. rotcurshape does surprisingly bad on exact data, and often
complains about taking the sqrt of a negative number.  Adding a little noise
will speed up convergence! 
rotcurshape sometimes needs inititial conditions
 pathetically close to a minimum to converge, and more than often complains
with the message 
### Warning [rotcurshape]: nllsqfit=-4: must find better solution (n=225)
### Warning [rotcurshape]: ROTCUR: problems with matrix inversion
</pre><p>
if <b>beam=</b> is used, the map is also used to estimate beam smearing corrections.
 This is still a totally untested  feature of the code. 
<h2><a name='sect8' href='#toc8'>See Also</a></h2>
<a href='rotcurtab.1.html'>rotcurtab(1NEMO)</a>
,
<a href='rotcur.1.html'>rotcur(1NEMO)</a>
, <a href='ccdvel.1.html'>ccdvel(1NEMO)</a>
, <a href='tabcomment.1.html'>tabcomment(1NEMO)</a>
, <a href='rotcurves.1.html'>rotcurves(1NEMO)</a>
, <a href='pvtrace.1.html'>pvtrace(1NEMO)</a>
,
<a href='ccdmom.1.html'>ccdmom(1NEMO)</a>
, <a href='tabnllsqfit.1.html'>tabnllsqfit(1NEMO)</a>
, <a href='rotcurshape.5.html'>rotcurshape(5NEMO)</a>
, <a href='loadobj.3.html'>loadobj(3NEMO)</a>
,
gal(AIPS), <a href='nllsqfit.3.html'>nllsqfit(3NEMO)</a>
, <a href='rotcur.5.html'>rotcur(5NEMO)</a>
 <br>
<pre>GBKFIT: http://supercomputing.swin.edu.au/projects/gbkfit/
</pre>
<h2><a name='sect9' href='#toc9'>Author</a></h2>
Peter Teuben 
<h2><a name='sect10' href='#toc10'>Update History</a></h2>
<br>
<pre>20-jul-02<tt> </tt>&nbsp;<tt> </tt>&nbsp;0.9 cloned off rotcur<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
10-sep-02<tt> </tt>&nbsp;<tt> </tt>&nbsp;1.0 implemented an image version for resid=<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
19-sep-02<tt> </tt>&nbsp;<tt> </tt>&nbsp;1.0d added exp (vMoorsel&amp;Wells 1985), and nfw<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
13-dec-02 <tt> </tt>&nbsp;<tt> </tt>&nbsp;1.0h added (corrected) power law rotcur<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
11-oct-03<tt> </tt>&nbsp;<tt> </tt>&nbsp;fixed up for adass 2003  <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
26-may-04<tt> </tt>&nbsp;<tt> </tt>&nbsp;1.2e fixed sqrt(n) bug in sigma, improved nsigma&gt;0 iterations<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
13-jun-04<tt> </tt>&nbsp;<tt> </tt>&nbsp;1.3: added fit= option to save a fitted map<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
30-jan-08<tt> </tt>&nbsp;<tt> </tt>&nbsp;1.4: with new rotcurtab minor overhaul of code<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
28-may-20<tt> </tt>&nbsp;<tt> </tt>&nbsp;added arctan<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
</pre><p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Parameters</a></li>
<li><a name='toc4' href='#sect4'>Rotcur Functions</a></li>
<li><a name='toc5' href='#sect5'>Example</a></li>
<li><a name='toc6' href='#sect6'>Files</a></li>
<li><a name='toc7' href='#sect7'>Caveat</a></li>
<li><a name='toc8' href='#sect8'>See Also</a></li>
<li><a name='toc9' href='#sect9'>Author</a></li>
<li><a name='toc10' href='#sect10'>Update History</a></li>
</ul>
</body>
</html>
