<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>UUEXPLODE(1L) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>
 
<h2><a name='sect0' href='#toc0'>Name</a></h2>
uuexplode - decode multiple and/or multipart uuencoded files to their
target files 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>uuexplode</b> [-hqslcfw] [-t dirname] [filename, filename...]

<h2><a name='sect2' href='#toc2'>Description</a></h2>
<b>uuexplode</b> is a "smart", fast uudecoder that will decode one
or more files consisting of complete uuencoded files. The target files can
be written in any user specified directory or in current. It is upward compatible
with <a href='uudecode.1.html'>uudecode(1)</a>
 provided that the encoder program used to create the input
to <b>uuexplode</b> has more or less followed the format described in <a href='uuencode.5.html'>uuencode(5)</a>
.
See Technical Notes below. <p>
If no filename(s) is supplied, input is read
from stdin. It can also write to stdout and hence act as a proper filter.
<p>
<b>uuexplode </b> automatically ignores lines that do not appear to be part of
the uuencoded file. This is particularly useful in uudecoding files that
have been concatenated from several email or news postings <i>without</i> stripping
off the headers or otherwise editing extraneous content. A lot of effort
was put into ensuring that erroneous target files are not written, several
error and warning messages are written to stdout when <b>uuexplode</b> finds something
in the input it doesn&rsquo;t accept or just finds strange. The messages are meant
to be self explanatory and contain line numbers in the input file. Note
that when warnings are issued, the output is still most likely correct.

<h2><a name='sect3' href='#toc3'>Options</a></h2>

<dl>

<dt><b>-h</b> </dt>
<dd>Print usage message stdout. </dd>

<dt><b>-q</b> </dt>
<dd>Quiet. Do not print any diagnostics,
errors or warning messages - no matter what goes wrong. </dd>

<dt><b>-s</b> </dt>
<dd>Write data to stdout
instead of to the target file. Only the very first target file found in
the input will be written, then <b>uuexplode</b> exits. By the "first" file is
meant the first file actually containing any decodable uucode at all. This
file may not be in the first input file if there are more than one. All
warning/error messages go to stderr so there is no need to use -q with -s.
</dd>

<dt><b>-l</b> </dt>
<dd>Lenient mode. This allows for the short data line, the one not beginning
with an "M"at the end of a uucode block, to have a non-standard length. Use
this as a second attempt if a target file seems to come out corrupted even
if no warnings were printed during decoding. Note: -l causes the security
of uucode recognition to drop quite considerably, do not use casually. </dd>

<dt><b>-c</b>
</dt>
<dd>Careless mode. This stops the checks for illegal characters in the short
data line. Its main use is in conjunction with -f when it allows decoding
of uucode in the character range [&gt;..}] that some non-standard encoders produce.
This kind of code is transparent to a "dumb" uudecode program. Never use
this option unless you know you have non-standard uucode. </dd>

<dt><b>-f</b> </dt>
<dd>Fast mode. This
stops the checks for illegal characters in the normal uucode data lines.
It makes the decoding go faster, but not significantly (in fact probably
not even noticably). Normally this would only be used with -c if you know
you have uucode with a non-standard character range. The sequrity of uucode
recognition with -f -c is <i>much</i> lower than normal. </dd>

<dt><b>-w</b> </dt>
<dd>Overwite. Without this,
<b>uuexplode</b> will refuse to overwrite a target file that already exists. </dd>

<dt><b>-t
dirname</b> </dt>
<dd>Target directory. The named directory does not have to exist, it
will be created. Should this fail, <b>uuexplode</b> exits and no target files will
be written. Without -t, the target files always end up in current directory.
</dd>
</dl>

<h2><a name='sect4' href='#toc4'>Technical Notes</a></h2>
This is for advanced users who know the uucode format well
and want to know more about what <b>uuexplode</b> accepts as valid uucode. A number
of constraints are put on it: 
<ol>
<li>The first line after the &rsquo;begin&rsquo;-line is a uucode
line if all characters are valid, it begins with [SPC..M,&rsquo;] and the length
is not totally absurd with respect to what the first char was. </li><li>There is
at least a \n behind each uucode line. There may be a \r also. </li><li>If there are
extra chars at the end of the data lines it is present in all lines, even
the last &lsquo;-line. And always the same number of chars. </li><li>There are no extra chars
behind the &rsquo;end&rsquo;-line except \n or \r\n </li><li>The normal uucode lines are always 45
bytes (60 chars) and have &rsquo;M&rsquo; as length indicator. A "standard" uudecode program
does not care about this at all. </li><li>No valid uucode contains ASCII &gt; &rsquo;a&rsquo;. Note
that one can also use the range [&gt;..}] since bit 6 of the chars are unused.
Again a "standard" uudecode program will happily decode such data, uuexplode
will only do this with -f -cc. There are uuencoders (e.g. on the Macintosh)
that produce such uucode. </li><li>The end of a uucode block resides in the same
input file (or stdin) as the corresponding &rsquo;begin&rsquo;-line. </li><li>All parts belonging
to the same target file(s) are in correct order in the input. </li><li>The input
contains no characers with ASCII code less than 32. </li>
</ol>
<p>
A small list of capabilities
concerning garbage lines: <br>
No assumptions whatsoever are made about the format of a garbage line. <br>
Handles garbage between all the last three lines of a uucode block. <br>
Handles bogus SPACE/&lsquo; lines between parts (and at the end) of the same block.
<br>
Handles bogus short data lines in the middle of a uucode block. <br>
Handles short or even empty uucode blocks correctly. <br>
Tolerates optional checksum/"guard" character(s) at the end of data lines.
<br>
Tolerates SPACE or &lsquo; as zero-code. The empty-line can be SPACE, &lsquo; or &lsquo;&lsquo;. 
<h2><a name='sect5' href='#toc5'>Returns</a></h2>
If
all decoding went well, the returncode is 0. Otherwise it is the logical
OR of the following values: <br>
1 &nbsp;&nbsp;At least one warning was issued <br>
2 &nbsp;&nbsp;At least one error occurred, possibly casuing a target file not to be
 created <br>
4 &nbsp;&nbsp;A target file already existed (only if -w was not actice) 
<h2><a name='sect6' href='#toc6'>Bugs</a></h2>
Some of
the warnings and errors are not quite as self explanatory as one would
wish. A user that does not know the uucode format and does not want to know,
may not be able to understand why the file he tried to decode failed. <p>
The
options -c and -l require at least rudimentary knowledge of the uucode format
to be really useful. <p>
There is no proper standard formally specifying the
format of uucode or what a uudecode algorithm shall accept as valid input.
This program tries to be lenient enough to accept all the common variants
while still being as pedantic as possible. There are variants of uuencoders
out there producing (at least capable of producing) uucode that uuexplode
does not accept. A present no such <i>commonly</i> used uuencoders are known to
me. <p>
The algorithms used to detect valid uucode are not based on proper statistical
analysis of uuencoded data with garabage lines in it. Instead, some fairly
rigid theoretical analysis, partly based on what kind of garbage normally
occur in Email and News postings (but not limited to those) was done. It
<i>may</i> not work as well with totally random garbage interleaved with the uucode.

<h2><a name='sect7' href='#toc7'>See Also</a></h2>
<a href='uuencode.5.html'>uuencode(5)</a>
, <a href='uuencode.1.html'>uuencode(1)</a>
, <a href='uudecode.1.html'>uudecode(1)</a>
 
<h2><a name='sect8' href='#toc8'>Author</a></h2>
Michael Bergman (euambn@eua.ericsson.se)

<p> Uuexplode was originally based on a program called "kiss", written by
Kevin Young. This program was part of a collection of uucode tools called
<b>uuxfer</b>. The actual decoding function that decodes one line of uucode is
also written by Kevin and altough all the other code has been almost completely
rewritten this remains unaltered. 
<p> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<li><a name='toc4' href='#sect4'>Technical Notes</a></li>
<li><a name='toc5' href='#sect5'>Returns</a></li>
<li><a name='toc6' href='#sect6'>Bugs</a></li>
<li><a name='toc7' href='#sect7'>See Also</a></li>
<li><a name='toc8' href='#sect8'>Author</a></li>
</ul>
</body>
</html>
