<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>BENCH(5NEMO) manual page</title>
</head>
<body bgcolor='white'>
This HTML automatically generated with <A HREF=http://manpages.ubuntu.com/manpages/bionic/man1/rman.1.html>rman</A> for <A HREF=https://astronemo.readthedocs.io>NEMO</A><br>
<a href='#toc'>Table of Contents</a><p>

<p> 
<h2><a name='sect0' href='#toc0'>Name</a></h2>
bench - various NEMO benchmarks 
<p> 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<br>
<pre>/usr/bin/time $NEMO/src/scripts/nemo.bench
make -f Benchfile clean all
nemobench LABEL COMMAND
</pre>
<p> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
There are several methods to compare the performance of NEMO
on different processors or environments: 
<p> <blockquote>
<p> 
<dl>

<dt>0.</dt>
<dd>The command <b>make bench5</b> from
the $NEMO directory runs a small number of benchmarks designed to each
takae 5 seconds on a given CPU. An average <i>speed</i> is then computed to compare
different compilers and/or CPU&rsquo;s, an idea simular to the <i>geekbench</i> suite
of tests. 
<p> </dd>

<dt>1.</dt>
<dd>The command <b>make bench</b> from the $NEMO directory runs a standard
benchmark of about a dozen  selected NEMO programs.  It should run in about
30 seconds on a ~2020 computer. A short table (see below in RESULTS) lists
results from some recent computers. 
<p> </dd>

<dt>2.</dt>
<dd>The command <b>make bench5</b> from the $NEMO
directory runs a standard benchmark of (currently) 6 nbody runs, all calibrated
to take 5 seconds on a specific machine. the average of those will result
in a rating (speed) of 1000. Most machines post ~2020 should get a <i>nemobench5</i>
(SEE BELOW) of over 1000. 
<p> 
<p> </dd>

<dt>3.</dt>
<dd>Various <b>Benchfile</b> filles scattered through
the $NEMO source tree contain benchmarks. There is no wrapper like "make
check" has for Testfile&rsquo;s 
<p> </dd>

<dt>4.</dt>
<dd>Selected man pages have some examples. Over time
these should be moved into the Benchfile in the source directory where
this program is maintained. Some are mentioned below in this man page. 
<p> <blockquote></dd>
</dl>
<p>
Unless
otherwise noted, benchmarks are always performed at the max power settings
of a laptop. In many cases the compiler version also will make a difference.
An example is the NEMOBENCH5, which lost 10% in speed going from gcc-11
to gcc-12! <p>
On KDE Ubuntu if the cpupower-gui is set to Powersave, one actually
gets better performance, as the Performance setting also scales up many
desktop apps, competing with the NEMO benchmark. 
<p> </blockquote>
</blockquote>

<h2><a name='sect3' href='#toc3'>Nemobench5</a></h2>

<p> The NEMOBENCH5
benchmark (cd $NEMO;make bench5) runs a number (currently 6) N-body codes
all calibrated to take 5.0 seconds on an i5-1135G7 in turbo mode (4.2GHz)
using gcc-11. The NEMOBENCH5 rating is defined as 5000 divided by the average
of those CPU times. Thus the i5-1135G7 has a score of 1000.  This definition
can be adjusted to 10s runs when the time comes that processors run too
fast, there is a parameter internal to the nemo.bench script, and could
also be adjusted if more codes are used. <br>
<pre>M4-air        <tt> </tt>&nbsp;<tt> </tt>&nbsp;2000  <tt> </tt>&nbsp;<tt> </tt>&nbsp;~3700(6)
i7-14700<tt> </tt>&nbsp;<tt> </tt>&nbsp;1468<tt> </tt>&nbsp;<tt> </tt>&nbsp;-
i9-13900K<tt> </tt>&nbsp;<tt> </tt>&nbsp;-<tt> </tt>&nbsp;<tt> </tt>&nbsp;2133
i9-12900K<tt> </tt>&nbsp;<tt> </tt>&nbsp;-<tt> </tt>&nbsp;<tt> </tt>&nbsp;n/a ~2000
M2      <tt> </tt>&nbsp;<tt> </tt>&nbsp;1540<tt> </tt>&nbsp;<tt> </tt>&nbsp;n/a 1919, 1899
i9-12900H<tt> </tt>&nbsp;<tt> </tt>&nbsp;-<tt> </tt>&nbsp;<tt> </tt>&nbsp;n/a 1851
M1-Max<tt> </tt>&nbsp;<tt> </tt>&nbsp;-<tt> </tt>&nbsp;<tt> </tt>&nbsp;n/a 1785
i7-12800H<tt> </tt>&nbsp;<tt> </tt>&nbsp;-<tt> </tt>&nbsp;<tt> </tt>&nbsp;n/a 1654
i9-11980HK<tt> </tt>&nbsp;<tt> </tt>&nbsp;-<tt> </tt>&nbsp;<tt> </tt>&nbsp;n/a 1616
ultra 9 - 185H<tt> </tt>&nbsp;<tt> </tt>&nbsp;1364<tt> </tt>&nbsp;<tt> </tt>&nbsp;(hypothetical 5.1/4.8)
i9-12900K<tt> </tt>&nbsp;<tt> </tt>&nbsp;1330<tt> </tt>&nbsp;<tt> </tt>&nbsp;jansky gcc 11.2.0
ultra 7 - 155H<tt> </tt>&nbsp;<tt> </tt>&nbsp;1283<tt> </tt>&nbsp;<tt> </tt>&nbsp;darter76 gcc 11.4.0 (gcc-13 13% slower)
i7-1260P<tt> </tt>&nbsp;<tt> </tt>&nbsp;1261<tt> </tt>&nbsp;<tt> </tt>&nbsp;k2
i5-1240P<tt> </tt>&nbsp;<tt> </tt>&nbsp;1155<tt> </tt>&nbsp;<tt> </tt>&nbsp;chromebook
M1 (Macbook Air)<tt> </tt>&nbsp;<tt> </tt>&nbsp;1269<tt> </tt>&nbsp;<tt> </tt>&nbsp;n/a 1750 / 7xxxx
i7-1260P<tt> </tt>&nbsp;<tt> </tt>&nbsp;1250<tt> </tt>&nbsp;<tt> </tt>&nbsp;k2 - but only on full power
i5-1240P<tt> </tt>&nbsp;<tt> </tt>&nbsp;1155<tt> </tt>&nbsp;<tt> </tt>&nbsp;chromebook (frameworks)
i7-11800H<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;n/a<tt> </tt>&nbsp;<tt> </tt>&nbsp;1474
i7-1185G7<tt> </tt>&nbsp;<tt> </tt>&nbsp;1060<tt> </tt>&nbsp;<tt> </tt>&nbsp;Dell Latitude 5420
i5-1135G7<tt> </tt>&nbsp;<tt> </tt>&nbsp;1000<tt> </tt>&nbsp;<tt> </tt>&nbsp;XPS13 1460 /
AMD threadripper 3960x<tt> </tt>&nbsp;<tt> </tt>&nbsp;896<tt> </tt>&nbsp;<tt> </tt>&nbsp;AlexBox
AMD Ryzen 7 5800H<tt> </tt>&nbsp;<tt> </tt>&nbsp;891<tt> </tt>&nbsp;<tt> </tt>&nbsp;beelink 
i5-10400H<tt> </tt>&nbsp;<tt> </tt>&nbsp;700<tt> </tt>&nbsp;<tt> </tt>&nbsp;Dell Precision 3351 (astroumd)
AMD EPYC 7302 @ 3.0GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;630<tt> </tt>&nbsp;<tt> </tt>&nbsp;lma 1000/ 28000
Intel Core i9-9900X<tt> </tt>&nbsp;<tt> </tt>&nbsp;-<tt> </tt>&nbsp;<tt> </tt>&nbsp;geminid 1214 / 9467
Xeon Gold 5218 @ 2.30 GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;761<tt> </tt>&nbsp;<tt> </tt>&nbsp;unity/node99 1100 / 8610
i5-10210U @ 1.60 GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;822 <tt> </tt>&nbsp;<tt> </tt>&nbsp;X1Y4  clang-18
i5-10210U @ 1.60 GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;732 <tt> </tt>&nbsp;<tt> </tt>&nbsp;X1Y4  1029 / 3194
Xeon(R) Silver 4114 @ 2.20GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;-<tt> </tt>&nbsp;<tt> </tt>&nbsp;terra 777 / 10213
i7-8550U @ 1.80 GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;548 <tt> </tt>&nbsp;<tt> </tt>&nbsp;T480 (1600) 696 / 1935
Xeon E-2186G 3.80 GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;- <tt> </tt>&nbsp;<tt> </tt>&nbsp;aurora 1313 / 6721
i7-3820QM @ 2.70 GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;498<tt> </tt>&nbsp;<tt> </tt>&nbsp;MacBookPro (Retina, Mid 2012)
i7-3820 @ 3.60 GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;414 <tt> </tt>&nbsp;<tt> </tt>&nbsp;dante 833 / 3693
Xeon(R) E3-1280 @ 3.50 GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;384<tt> </tt>&nbsp;<tt> </tt>&nbsp;chara 828 / 3117
i7-3630QM @ 2.40 GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;429<tt> </tt>&nbsp;<tt> </tt>&nbsp;T530 (1200) 762 / 3006 
Xeon E5-2623 v4 @ 2.60 GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;-<tt> </tt>&nbsp;<tt> </tt>&nbsp;kraken 782 / 5800
Xeon X5550  @ 2.67 GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;256<tt> </tt>&nbsp;<tt> </tt>&nbsp;sdp 566 / 3938
AMD Opteron(tm) 6380<tt> </tt>&nbsp;<tt> </tt>&nbsp;234<tt> </tt>&nbsp;<tt> </tt>&nbsp;yorp (2023)
</pre>
<p> A typical output of bench5 might look as follows: 
<p> <br>
<pre>CPU_USAGE  directcode  :  11.31  11.29  0.00  0.00  0.00  1787697842
CPU_USAGE  gyrfalcON   :  9.09   9.08   0.00  0.00  0.00  1787698975
CPU_USAGE  hackcode1   :  11.69  11.68  0.00  0.00  0.00  1787699885
CPU_USAGE  orbint      :  9.81   9.80   0.00  0.00  0.00  1787701056
CPU_USAGE  potcode     :  11.01  10.99  0.01  0.00  0.00  1787702038
CPU_USAGE  treecode1   :  10.94  10.93  0.01  0.00  0.00  1787703140
NEMOBENCH5 score: 469.85
</pre>where on this particular CPU there is a diversity of speeds. Some CPU show
even more diversity. 
<p> <p>
Here is an example how to use nemobench5 is parallel
mode on a 32 core Xeon, where a single NEMOBENCH5 has a score of 630. Since
all codes are single core, gnu parallel is used to run them in parallel,
which should scale linearly as long as memory is not exhausted (this particular
CPU has 512GB memory): 
<p> <br>
<pre>for j in 2 4 8 12 16 24 32 48 64 128; do
    $NEMO/src/scripts/nemo.bench mode=5 np=$j | txtpar - p0=npt,1,2 p1=sum,1,2
p2=mean,1,2
done
  2  1256  628
  4  2512  628
  8  5020  628
 12  7512  626
 16 10047  628
 24 15024  626
 32 20025  626
 48 20589  429
 64 21517  336
128 20792  162
(numbers were rounded to improve readability)
</pre>
<p> 
<p> 
<h2><a name='sect4' href='#toc4'>Bench</a></h2>
Here are the results of the "make bench" benchmark. The time is the
user CPU time. If two values are listed after the machine name, these are
the GeekBench5 values. <br>
<pre>Intel Core i5-1135G7<tt> </tt>&nbsp;<tt> </tt>&nbsp;15.4<tt> </tt>&nbsp;<tt> </tt>&nbsp;XPS13 1460 /
AMD EPYC 7302 @ 3.0GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;23.9<tt> </tt>&nbsp;<tt> </tt>&nbsp;lma 1000/ 28000
Intel Core i9-9900X<tt> </tt>&nbsp;<tt> </tt>&nbsp;25.8<tt> </tt>&nbsp;<tt> </tt>&nbsp;geminid 1214 / 9467
i5-10210U CPU @ 1.60GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;29.4 <tt> </tt>&nbsp;<tt> </tt>&nbsp;X1Y4  1029 / 3194
Xeon(R) Silver 4114 @ 2.20GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;37.1<tt> </tt>&nbsp;<tt> </tt>&nbsp;terra 777 / 10213
i7-8550U CPU @ 1.80GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;40.6 <tt> </tt>&nbsp;<tt> </tt>&nbsp;T480 (1600) 696 / 1935
Xeon E-2186G 3.80GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;52.6 <tt> </tt>&nbsp;<tt> </tt>&nbsp;aurora 1313 / 6721
i7-3820 CPU @ 3.60GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;??/67.5 <tt> </tt>&nbsp;<tt> </tt>&nbsp;dante 833 / 3693
Xeon(R) CPU E3-1280 @ 3.50GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;??/70.3 <tt> </tt>&nbsp;<tt> </tt>&nbsp;chara 828 / 3117
i7-3630QM CPU @ 2.40GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;76.2 <tt> </tt>&nbsp;<tt> </tt>&nbsp;T530 (1200) 762 / 3006 
Xeon(R) E5-2623 v4 @ 2.60GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;42.1/79.4 <tt> </tt>&nbsp;<tt> </tt>&nbsp;kraken 782 / 5800
Xeon(R) X5550  @ 2.67GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;115.4<tt> </tt>&nbsp;<tt> </tt>&nbsp;sdp 566 / 3938
</pre>
<p> Keep in mind for most of these a default compilation was used.  Some benchmarks
are known to be able to improved by up to a factor of two with selected
compiler and options changes. 
<p> 
<p> <p>
The following tasks are run in the standard
NEMO bench, for details see the src/scripts/nemo.bench  script. <br>
<pre>directcode nbody=3072 out=d0 seed=123 
hackcode1 nbody=10240  out=h0 seed=123 
mkplummer p0 10240 seed=123 
gyrfalcON p0 p1 kmax=6 tstop=2 eps=0.05
potcode p0 p2 freqout=10 freq=1000 tstop=2 potname=plummer
mkspiral s0 $nbody3 nmodel=40 seed=123 
ccdmath "" c0 &rsquo;ranu(0,1)&rsquo; size=256 seed=123
ccdpot c0 c1 
mkorbit o0 x=1 e=1 lz=1 potname=log
orbint o0 o1 nsteps=10000000 dt=0.001 nsave=100000
</pre>In addition each data file that is produced is checksummed and compared
to a baseline version using <a href='bsf.1.html'><i>bsf(1NEMO)</i></a>
 if the argument <b>bsf=1</b> is added. 
<p>

<h2><a name='sect5' href='#toc5'>Bench8</a></h2>
The <b>bench8</b> measures how well your CPU performs simple OpenMP algorithm
as more cores are employed. This can be an effective way to determine how
well your CPU adjusts under increased power demands, for example laptops
with thermal protection will scale down their cpu frequency as more cores
are employed or as a long benchmark heats up the CPU. 
<p> <br>
<pre>   scaling2 umax=20000 np=1 iter=20
   scaling2 umax=20000 np=2 iter=40
   scaling2 umax=20000 np=4 iter=80
</pre>
<p> Look at the elapsed time to follow how well a particular CPU performs
at increased load: 
<p> <br>
<pre>CPU     <tt> </tt>&nbsp;<tt> </tt>&nbsp;1<tt> </tt>&nbsp;<tt> </tt>&nbsp;2<tt> </tt>&nbsp;<tt> </tt>&nbsp;4<tt> </tt>&nbsp;<tt> </tt>&nbsp;8<tt> </tt>&nbsp;<tt> </tt>&nbsp;16
i7-1260P (pow)<tt> </tt>&nbsp;<tt> </tt>&nbsp;7.0<tt> </tt>&nbsp;<tt> </tt>&nbsp;7.1<tt> </tt>&nbsp;<tt> </tt>&nbsp;8.5<tt> </tt>&nbsp;<tt> </tt>&nbsp;18.7<tt> </tt>&nbsp;<tt> </tt>&nbsp;24.6
i7-1260P (bat)<tt> </tt>&nbsp;<tt> </tt>&nbsp;10.2<tt> </tt>&nbsp;<tt> </tt>&nbsp;13.0<tt> </tt>&nbsp;<tt> </tt>&nbsp;17.6<tt> </tt>&nbsp;<tt> </tt>&nbsp;40.4<tt> </tt>&nbsp;<tt> </tt>&nbsp;59.9
jansky   <tt> </tt>&nbsp;<tt> </tt>&nbsp;6.4<tt> </tt>&nbsp;<tt> </tt>&nbsp;6.5<tt> </tt>&nbsp;<tt> </tt>&nbsp;6.5<tt> </tt>&nbsp;<tt> </tt>&nbsp;6.7<tt> </tt>&nbsp;<tt> </tt>&nbsp;17.4
lma     <tt> </tt>&nbsp;<tt> </tt>&nbsp;12.2<tt> </tt>&nbsp;<tt> </tt>&nbsp;12.3<tt> </tt>&nbsp;<tt> </tt>&nbsp;12.2<tt> </tt>&nbsp;<tt> </tt>&nbsp;12.3<tt> </tt>&nbsp;<tt> </tt>&nbsp;12.4
M2      <tt> </tt>&nbsp;<tt> </tt>&nbsp;6.9<tt> </tt>&nbsp;<tt> </tt>&nbsp;7.2<tt> </tt>&nbsp;<tt> </tt>&nbsp;7.6<tt> </tt>&nbsp;<tt> </tt>&nbsp;9.4<tt> </tt>&nbsp;<tt> </tt>&nbsp;19.3
</pre>
<p> 
<p> 
<p> 
<h2><a name='sect6' href='#toc6'>Bench10</a></h2>
Not really implemented, but this will be benchmarks orchestrated
via the <b>Benchfile</b>&rsquo;s found in the source tree. 
<p> 
<h2><a name='sect7' href='#toc7'>Oldest Bench</a></h2>
At the inception
of NEMO in 1986 there was no real benchmark, so for a while (as computers
were relatively slow still) we used the default <a href='hackcode1.1.html'><i>hackcode1(1NEMO)</i></a>
 setting,
where 128 particles in virial equilibrium are integrated for 64 timesteps:
<br>
<pre>      /usr/bin/time hackcode1 tstop=2  &gt; /dev/null
</pre>
<p> <p>
On a Sun 3/50 (our development machine) this took about 5 seconds per
step. Now, nearly 35 years later, my laptop runs this about 50,000 times
faster. Looking in more detail at the original NEMO manual: 
<p> <br>
<pre>                       cpu/steps
sun 3/60:  20 MHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;2.28        
i5-1135G7: 4200 MHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;0.0000875   
</pre>Despite that the cpu was 210 times faster, the code ran 26,000 faster. A
very impressive factor of 120 improvement in chip and possibly some compiler
technology. The NEMO users guide has an appendix in which this benchmark
is listed for a variety of computers since 1986. 
<p> 
<h2><a name='sect8' href='#toc8'>Caveats</a></h2>
Defining and running
a benchmark can be very tricky stuff. It might be important to separate
disk I/O from CPU usage.   The unix <a href='time.1.html'><i>time(1)</i></a>
  command can be a help. The output
from bash::time is a bit different form csh::time, and yet different from
/usr/bin/time. Unless you find a special one, we prefer the csh::time, since
the output clearly separates user, system and wall clock time, and also
reports the I/O, viz. <br>
<pre>   % time ls 
   0.012u 0.068s 0:00.77 9.0%<tt> </tt>&nbsp;<tt> </tt>&nbsp;0+0k 8376+0io 0pf+0w
   2.324u 1.080s 0:09.25 36.7%<tt> </tt>&nbsp;<tt> </tt>&nbsp;0+0k 1049384+2097160io 2pf+0w
   1.876u 0.788s 0:03.63 73.0%<tt> </tt>&nbsp;<tt> </tt>&nbsp;0+0k 0+2097160io 0pf+0w
</pre>On linux the command  <br>
<pre>   echo 1 &gt; &gt; /proc/sys/vm/drop_caches
</pre>will clear the disk cache in memory, so your program will be forced to
read from disk, with all possible interference from other programs <p>
In NEMO
another useful addition to the benchmark is that the output can be turned
off easily, by using <b>out=.</b>, viz. <br>
<pre>    % sudo $NEMO/src/scripts/clearcache
    % time ccdsmooth n1 . dir=x
    0.852u 1.068s 0:12.41 15.3%<tt> </tt>&nbsp;<tt> </tt>&nbsp;0+0k 2098312+0io 6pf+0w
    0.812u 0.400s 0:01.21 100.0%<tt> </tt>&nbsp;<tt> </tt>&nbsp;0+0k 0+0io 0pf+0w
    0.820u 0.380s 0:01.20 100.0%<tt> </tt>&nbsp;<tt> </tt>&nbsp;0+0k 0+0io 0pf+0w
</pre>where the last two instances were just re-running the same command, but
now clearly showing the effect of reading the file from memory instead
of disk. By repeating this whole series a few times, an lower bound to the
 wall clock time is more likely to properly account for the I/O overhead
time. <p>
Rule of thumb: always run a benchmark a few times to see if a hot
CPU slows down the benchmark. If I/O is cached. Other tasks are interfering.

<p> 
<h2><a name='sect9' href='#toc9'> "others"</a></h2>
A few other man pages in NEMO also maintain their own list how
its program compares under different compilers/options/cpu options: <br>
<pre>CGS(1NEMO)
scfm(1NEMO)
</pre><p>
Other industry benchmarks: <br>
<pre>    Geekbench 5 (very wide variety of compute workloads - baseline is i3-8100)
    Linpack   (focus on floating point operations - Gflops)
    SPEC CPU 2017 ($$$) benchmark - 
</pre>
<p> 
<h2><a name='sect10' href='#toc10'>Tabbench</a></h2>
The table I/O benchmark uses a 100M row dataset with 3 columns,
representing X,Y,Z of which the radius R=sqrt(X^2+Y^2+Z^2) is computed. This
table is about 2.7 GB in size. Of course reading the table is all dependent
on the HDD/SDD, but in the case described here this was a fast SSD, and
took 2 sec to read, or just over 1000 MB/sec. <br>
<pre>    /usr/bin/time tabgen tab3 100000000 3
    /usr/bin/time tabbench2 . mode=-1
    

this bench will need to be repeated for mode=0,1,2,3 to estimate the different
components as they
are added to the workflow. The tabgen(1NEMO) is dominated by
drawing random numbers and writing them using printf(3) , which is slow.

    80s   writing, using tabgen
     2s   reading in tabbench2
    22s   parsing in numbers  [np.loadtxt takes 748 sec!!!]
     6s   using fie(3NEMO) to compute radii
     1s   using np.sqrt(), and presumably C&rsquo;s sqrt() as well
    
</pre>
<p> 
<h2><a name='sect11' href='#toc11'>Parallel</a></h2>
The GNU <a href='parallel.1.html'><i>parallel(1)</i></a>
 tool can be of great use if your tasks are
pure single core and you have enough cores (most laptops have at least
4 these days) and memory to fit your tasks.   As an example, here is something
contrived using <a href='mkplummer.1.html'><i>mkplummer(1NEMO)</i></a>
 that does not write to disk, so it should
be highly parallizable: 
<p> <br>
<pre>    nbody=10000000
    /usr/bin/time mkplummer . $nbody
    2.80user 0.45system 0:03.26elapsed 99%CPU
    
    echo mkplummer . $nbody  &gt; run.txt
    echo mkplummer . $nbody &gt;&gt; run.txt
    /usr/bin/time parallel --jobs 1 &lt; run.txt
    5.89user 0.83system 0:06.71elapsed 100%CPU
    
    /usr/bin/time parallel --jobs 2 &lt; run.txt
    6.00user 0.79system 0:03.44elapsed 197%CPU
</pre>
<p> which follows Amdahl&rsquo;s law close to 100%! 
<p> 
<p> 
<h2><a name='sect12' href='#toc12'>Considerations</a></h2>
Most programs
that need an output file, can use <b>out=-</b> to pass the data into a standard
Unix pipe, or even <b>out=.</b> to use a sink.  
<p> 
<h2><a name='sect13' href='#toc13'>See Also</a></h2>
<a href='gyrfalcON.1.html'>gyrfalcON(1NEMO)</a>
, <a href='data.5.html'>data(5NEMO)</a>
,
<a href='tabgen.1.html'>tabgen(1NEMO)</a>
, <a href='mkspiral.1.html'>mkspiral(1NEMO)</a>
, <a href='mkplummer.1.html'>mkplummer(1NEMO)</a>
, <a href='hackcode1.1.html'>hackcode1(1NEMO)</a>
, <a href='nbody1.1.html'>nbody1(1NEMO)</a>
,
<a href='scfm.1.html'>scfm(1NEMO)</a>
, <a href='CGS.1.html'>CGS(1NEMO)</a>
, <a href='triple.1.html'>triple(1NEMO)</a>
, <a href='accudate.l.html'>accudate(lNEMO)</a>
, <a href='bsf.1.html'>bsf(1NEMO)</a>
, <a href='nemobench.8.html'>nemobench(8NEMO)</a>

<p>

<p><a href='https://browser.geekbench.com/processor-benchmarks'>https://browser.geekbench.com/processor-benchmarks</a>
 
<p> 
<h2><a name='sect14' href='#toc14'>Author</a></h2>
Peter Teuben 
<p> 
<h2><a name='sect15' href='#toc15'>Files</a></h2>
<br>
<pre>$NEMO/src/scripts/nemo.bench<tt> </tt>&nbsp;<tt> </tt>&nbsp;Script uses by make bench/bench5/bench10
$NEMO/data   <tt> </tt>&nbsp;<tt> </tt>&nbsp;standard repository area for (small) data files.
Benchfile<tt> </tt>&nbsp;<tt> </tt>&nbsp;A Makefile that can orchestrate series of benchmarks
/tmp/nemobench.log<tt> </tt>&nbsp;<tt> </tt>&nbsp;The nemobench keeps logfile
</pre>
<p> 
<h2><a name='sect16' href='#toc16'>Update History</a></h2>
<br>
<pre>12-may-97<tt> </tt>&nbsp;<tt> </tt>&nbsp;created  <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
26-nov-03<tt> </tt>&nbsp;<tt> </tt>&nbsp;finally added some data<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
17-feb-04<tt> </tt>&nbsp;<tt> </tt>&nbsp;added bench0 comparison  <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
31-mar-05<tt> </tt>&nbsp;<tt> </tt>&nbsp;added some cygwin numbers, fixed input<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
6-may-11<tt> </tt>&nbsp;<tt> </tt>&nbsp;added i7 and SHMEM/HDD comparison<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
27-sep-13<tt> </tt>&nbsp;<tt> </tt>&nbsp;added caveats<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
6-jan-2018<tt> </tt>&nbsp;<tt> </tt>&nbsp;updated for V4, more balanced benchmarks <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
27-dec-2019<tt> </tt>&nbsp;<tt> </tt>&nbsp;nemo.bench; updated with potcode and orbint<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
26-jul-2020<tt> </tt>&nbsp;<tt> </tt>&nbsp;added timings / added geekbench5 <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
31-aug-2023<tt> </tt>&nbsp;<tt> </tt>&nbsp;added bench8<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
</pre><p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Nemobench5</a></li>
<li><a name='toc4' href='#sect4'>Bench</a></li>
<li><a name='toc5' href='#sect5'>Bench8</a></li>
<li><a name='toc6' href='#sect6'>Bench10</a></li>
<li><a name='toc7' href='#sect7'>Oldest Bench</a></li>
<li><a name='toc8' href='#sect8'>Caveats</a></li>
<li><a name='toc9' href='#sect9'> "others"</a></li>
<li><a name='toc10' href='#sect10'>Tabbench</a></li>
<li><a name='toc11' href='#sect11'>Parallel</a></li>
<li><a name='toc12' href='#sect12'>Considerations</a></li>
<li><a name='toc13' href='#sect13'>See Also</a></li>
<li><a name='toc14' href='#sect14'>Author</a></li>
<li><a name='toc15' href='#sect15'>Files</a></li>
<li><a name='toc16' href='#sect16'>Update History</a></li>
</ul>
</body>
</html>
