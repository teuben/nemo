<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>BENCH(5NEMO) manual page</title>
</head>
<body bgcolor='white'>
HTML automatically generated with <A HREF=http://manpages.ubuntu.com/manpages/bionic/man1/rman.1.html>rman</A><br>
<a href='#toc'>Table of Contents</a><p>

<p> 
<h2><a name='sect0' href='#toc0'>Name</a></h2>
bench - various NEMO benchmarks 
<p> 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<br>
<pre>/usr/bin/time $NEMO/src/scripts/nemo.bench
make -f Benchfile clean all
nemobench COMMAND
</pre>
<p> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
There are several methods to compare the performance of NEMO
on different processors or environments: 
<p> <blockquote>
<dl>

<dt>1.</dt>
<dd>The command <b>make bench</b> from
the $NEMO directory runs a standard benchmark of about a dozen  selected
NEMO programs.  It should run in about 30 seconds on a ~2020 computer. A
short table (see below in RESULTS) lists results from some recent computers.

<p> </dd>

<dt>2.</dt>
<dd>Various <b>Benchfile</b> filles scattered through the $NEMO source tree contain
benchmarks. There is no  wrapper like "make check" has for Testfile&rsquo;s 
<p> </dd>

<dt>3.</dt>
<dd>Selected
man pages have some examples. Over time these should be moved into the Benchfile
in the source directory where this program is maintained. Some are mentioned
below in this man page. 
<p> 
<p> </dd>
</dl>
</blockquote>

<h2><a name='sect3' href='#toc3'>Bench</a></h2>
Here are the results of the "make bench"
benchmark. The time is the user CPU time. If two values are listed after
the machine name, these are the GeekBench5 values. <br>
<pre>Intel Core i5-1135G7<tt> </tt>&nbsp;<tt> </tt>&nbsp;15.4<tt> </tt>&nbsp;<tt> </tt>&nbsp;XPS13 1460 /
AMD EPYC 7302 @ 3.0GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;23.9<tt> </tt>&nbsp;<tt> </tt>&nbsp;lma 1000/ 28000
Intel Core i9-9900X<tt> </tt>&nbsp;<tt> </tt>&nbsp;25.8<tt> </tt>&nbsp;<tt> </tt>&nbsp;geminid 1214 / 9467
i5-10210U CPU @ 1.60GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;29.4 <tt> </tt>&nbsp;<tt> </tt>&nbsp;X1Y4  1029 / 3194
Xeon(R) Silver 4114 @ 2.20GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;37.1<tt> </tt>&nbsp;<tt> </tt>&nbsp;terra 777 / 10213
i7-8550U CPU @ 1.80GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;40.6 <tt> </tt>&nbsp;<tt> </tt>&nbsp;T480 (1600) 696 / 1935
Xeon E-2186G 3.80GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;52.6 <tt> </tt>&nbsp;<tt> </tt>&nbsp;aurora 1313 / 6721
i7-3820 CPU @ 3.60GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;??/67.5 <tt> </tt>&nbsp;<tt> </tt>&nbsp;dante 833 / 3693
Xeon(R) CPU E3-1280 @ 3.50GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;??/70.3 <tt> </tt>&nbsp;<tt> </tt>&nbsp;chara 828 / 3117
i7-3630QM CPU @ 2.40GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;76.2 <tt> </tt>&nbsp;<tt> </tt>&nbsp;T530 (1200) 762 / 3006 
Xeon(R) E5-2623 v4 @ 2.60GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;42.1/79.4 <tt> </tt>&nbsp;<tt> </tt>&nbsp;kraken 782 / 5800
Xeon(R) X5550  @ 2.67GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;115.4<tt> </tt>&nbsp;<tt> </tt>&nbsp;sdp 566 / 3938
</pre>
<p> Keep in mind for most of these a default compilation was used.  Some benchmarks
are known to be able to improved by up to a factor of two with selected
compiler and options changes. 
<p> 
<p> <p>
The following tasks are run in the standard
NEMO bench, for details see the src/scripts/nemo.bench  script. <br>
<pre>directcode nbody=3072 out=d0 seed=123 
hackcode1 nbody=10240  out=h0 seed=123 
mkplummer p0 10240 seed=123 
gyrfalcON p0 p1 kmax=6 tstop=2 eps=0.05
potcode p0 p2 freqout=10 freq=1000 tstop=2 potname=plummer
mkspiral s0 $nbody3 nmodel=40 seed=123 
ccdmath "" c0 &rsquo;ranu(0,1)&rsquo; size=256 seed=123
ccdpot c0 c1 
mkorbit o0 x=1 e=1 lz=1 potname=log
orbint o0 o1 nsteps=10000000 dt=0.001 nsave=100000
</pre>In addition each data file that is produced is checksummed and compared
to a baseline version using <a href='bsf.1.html'><i>bsf(1NEMO)</i></a>
 if the argument <b>bsf=1</b> is added. 
<p>

<h2><a name='sect4' href='#toc4'>Nemobench5</a></h2>
The NEMOBENCH5 benchmark (cd $NEMO;make bench5) runs a number
(currently 6) N-body codes all calibrated to take 5.0 seconds on an i5-1135G7
in turbo mode (4.2GHz). The NEMOBENCH5 rating is defined as 5000 divided
by the average of those CPU times. Thus the i5-1135G7 has a score of 1000.
 This definition can be adjusted to 10s runs when the time comes that processors
run too fast, there is a parameter internal to the nemo.bench <br>
<pre>M1 (Macbook Air)    <tt> </tt>&nbsp;<tt> </tt>&nbsp;1269<tt> </tt>&nbsp;<tt> </tt>&nbsp;1750 / 7xxxx
Intel Core i5-1135G7<tt> </tt>&nbsp;<tt> </tt>&nbsp;1000<tt> </tt>&nbsp;<tt> </tt>&nbsp;XPS13 1460 /
AMD threadripper 3960x<tt> </tt>&nbsp;<tt> </tt>&nbsp;896<tt> </tt>&nbsp;<tt> </tt>&nbsp;AlexBox
AMD EPYC 7302 @ 3.0GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;630<tt> </tt>&nbsp;<tt> </tt>&nbsp;lma 1000/ 28000
Intel Core i9-9900X<tt> </tt>&nbsp;<tt> </tt>&nbsp;-<tt> </tt>&nbsp;<tt> </tt>&nbsp;geminid 1214 / 9467
Xeon Gold 5218 @ 2.30GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;761<tt> </tt>&nbsp;<tt> </tt>&nbsp;unity/node99 1100 / 8610
i5-10210U CPU @ 1.60GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;732 <tt> </tt>&nbsp;<tt> </tt>&nbsp;X1Y4  1029 / 3194
Xeon(R) Silver 4114 @ 2.20GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;-<tt> </tt>&nbsp;<tt> </tt>&nbsp;terra 777 / 10213
i7-8550U CPU @ 1.80GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;548 <tt> </tt>&nbsp;<tt> </tt>&nbsp;T480 (1600) 696 / 1935
Xeon E-2186G 3.80GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;- <tt> </tt>&nbsp;<tt> </tt>&nbsp;aurora 1313 / 6721
i7-3820QM @ 2.70 GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;498<tt> </tt>&nbsp;<tt> </tt>&nbsp;MacBookPro (Retina, Mid 2012)
i7-3820 CPU @ 3.60GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;414 <tt> </tt>&nbsp;<tt> </tt>&nbsp;dante 833 / 3693
Xeon(R) CPU E3-1280 @ 3.50GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;- <tt> </tt>&nbsp;<tt> </tt>&nbsp;chara 828 / 3117
i7-3630QM CPU @ 2.40GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;429 <tt> </tt>&nbsp;<tt> </tt>&nbsp;T530 (1200) 762 / 3006 
Xeon E5-2623 v4 @ 2.60GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;-<tt> </tt>&nbsp;<tt> </tt>&nbsp;kraken 782 / 5800
Xeon X5550  @ 2.67GHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;256<tt> </tt>&nbsp;<tt> </tt>&nbsp;sdp 566 / 3938
</pre>
<p> 
<h2><a name='sect5' href='#toc5'>Bench10</a></h2>
Not really implemented, but this will be benchmarks orchestrated
via the <b>Benchfile</b>&rsquo;s found in the source tree. 
<p> 
<h2><a name='sect6' href='#toc6'>Oldest Bench</a></h2>
At the inception
of NEMO in 1986 there was no real benchmark, so for a while (as computers
were relatively slow still) we used the default <a href='hackcode1.1.html'><i>hackcode1(1NEMO)</i></a>
 setting,
where 128 particles in virial equilibrium are integrated for 64 timesteps:
<br>
<pre>      /usr/bin/time hackcode1 tstop=2  &gt; /dev/null
</pre>
<p> <p>
On a Sun 3/50 (our development machine) this took about 5 seconds per
step. Now, nearly 35 years later, my laptop runs this about 50,000 times
faster. Looking in more detail at the original NEMO manual: 
<p> <br>
<pre>                       cpu/steps
sun 3/60:  20 MHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;2.28        
i5-1135G7: 4200 MHz<tt> </tt>&nbsp;<tt> </tt>&nbsp;0.0000875   
</pre>Despite that the cpu was 210 times faster, the code ran 26,000 faster. A
very impressive factor of 120 improvement in chip and possibly some compiler
technology. The NEMO users guide has an appendix in which this benchmark
is listed for a variety of computers since 1986. 
<p> 
<h2><a name='sect7' href='#toc7'>Caveats</a></h2>
Defining and running
a benchmark can be very tricky stuff. It might be important to separate
disk I/O from CPU usage.   The unix <a href='time.1.html'><i>time(1)</i></a>
  command can be a help. The output
from bash::time is a bit different form csh::time, and yet different from
/usr/bin/time. Unless you find a special one, we prefer the csh::time, since
the output clearly separates user, system and wall clock time, and also
reports the I/O, viz. <br>
<pre>   % time ls 
   0.012u 0.068s 0:00.77 9.0%<tt> </tt>&nbsp;<tt> </tt>&nbsp;0+0k 8376+0io 0pf+0w
   2.324u 1.080s 0:09.25 36.7%<tt> </tt>&nbsp;<tt> </tt>&nbsp;0+0k 1049384+2097160io 2pf+0w
   1.876u 0.788s 0:03.63 73.0%<tt> </tt>&nbsp;<tt> </tt>&nbsp;0+0k 0+2097160io 0pf+0w
</pre>On linux the command  <br>
<pre>   echo 1 &gt; &gt; /proc/sys/vm/drop_caches
</pre>will clear the disk cache in memory, so your program will be forced to
read from disk, with all possible interference from other programs <p>
In NEMO
another useful addition to the benchmark is that the output can be turned
off easily, by using <b>out=.</b>, viz. <br>
<pre>    % sudo $NEMO/src/scripts/clearcache
    % time ccdsmooth n1 . dir=x
    0.852u 1.068s 0:12.41 15.3%<tt> </tt>&nbsp;<tt> </tt>&nbsp;0+0k 2098312+0io 6pf+0w
    0.812u 0.400s 0:01.21 100.0%<tt> </tt>&nbsp;<tt> </tt>&nbsp;0+0k 0+0io 0pf+0w
    0.820u 0.380s 0:01.20 100.0%<tt> </tt>&nbsp;<tt> </tt>&nbsp;0+0k 0+0io 0pf+0w
</pre>where the last two instances were just re-running the same command, but
now clearly showing the effect of reading the file from memory instead
of disk. By repeating this whole series a few times, an lower bound to the
 wall clock time is more likely to properly account for the I/O overhead
time. <p>
Rule of thumb: always run a benchmark a few times to see if a hot
CPU slows down the benchmark. If I/O is cached. Other tasks are interfering.

<p> 
<h2><a name='sect8' href='#toc8'> "others"</a></h2>
A few other man pages in NEMO also maintain their own list how
its program compares under different compilers/options/cpu options: <br>
<pre>CGS(1NEMO)
scfm(1NEMO)
</pre><p>
Other industry benchmarks: <br>
<pre>    Geekbench 5 (very wide variety of compute workloads - baseline is i3-8100)
    Linpack   (focus on floating point operations - Gflops)
    SPEC CPU 2017 ($$$) benchmark - 
</pre>
<p> 
<h2><a name='sect9' href='#toc9'>Tabbench</a></h2>
The table I/O benchmark uses a 100M row dataset with 3 columns,
representing X,Y,Z of which the radius R=sqrt(X^2+Y^2+Z^2) is computed. This
table is about 2.7 GB in size. Of course reading the table is all dependent
on the HDD/SDD, but in the case described here this was a fast SSD, and
took 2 sec to read, or just over 1000 MB/sec. <br>
<pre>    /usr/bin/time tabgen tab3 100000000 3
    /usr/bin/time tabbench2 . mode=-1
    

this bench will need to be repeated for mode=0,1,2,3 to estimate the different
components as they
are added to the workflow. The tabgen(1NEMO) is dominated by
drawing random numbers and writing them using printf(3) , which is slow.

    80s   writing, using tabgen
     2s   reading in tabbench2
    22s   parsing in numbers  [np.loadtxt takes 748 sec!!!]
     6s   using fie(3NEMO) to compute radii
     1s   using np.sqrt(), and presumably C&rsquo;s sqrt() as well
    
</pre>
<p> 
<h2><a name='sect10' href='#toc10'>Parallel</a></h2>
The GNU <a href='parallel.1.html'><i>parallel(1)</i></a>
 tool can be of great use if your tasks are
pure single core and you have enough cores (most laptops have at least
4 these days) and memory to fit your tasks.   As an example, here is something
contrived using <a href='mkplummer.1.html'><i>mkplummer(1NEMO)</i></a>
 that does not write to disk, so it should
be highly parallizable: 
<p> <br>
<pre>    nbody=10000000
    /usr/bin/time mkplummer . $nbody
    2.80user 0.45system 0:03.26elapsed 99%CPU
    
    echo mkplummer . $nbody  &gt; run.txt
    echo mkplummer . $nbody &gt;&gt; run.txt
    /usr/bin/time parallel --jobs 1 &lt; run.txt
    5.89user 0.83system 0:06.71elapsed 100%CPU
    
    /usr/bin/time parallel --jobs 2 &lt; run.txt
    6.00user 0.79system 0:03.44elapsed 197%CPU
</pre>
<p> which follows Amdahl&rsquo;s law close to 100%! 
<p> 
<h2><a name='sect11' href='#toc11'>Considerations</a></h2>
Most programs
that need an output file, can use <b>out=-</b> to pass the data into a standard
Unix pipe, or even <b>out=.</b> to use a sink.  
<p> 
<h2><a name='sect12' href='#toc12'>See Also</a></h2>
<a href='gyrfalcON.1.html'>gyrfalcON(1NEMO)</a>
, <a href='data.5.html'>data(5NEMO)</a>
,
<a href='tabgen.1.html'>tabgen(1NEMO)</a>
, <a href='mkspiral.1.html'>mkspiral(1NEMO)</a>
, <a href='mkplummer.1.html'>mkplummer(1NEMO)</a>
, <a href='hackcode1.1.html'>hackcode1(1NEMO)</a>
, <a href='nbody1.1.html'>nbody1(1NEMO)</a>
,
<a href='scfm.1.html'>scfm(1NEMO)</a>
, <a href='CGS.1.html'>CGS(1NEMO)</a>
, <a href='triple.1.html'>triple(1NEMO)</a>
, <a href='accudate.l.html'>accudate(lNEMO)</a>
, <a href='bsf.1.html'>bsf(1NEMO)</a>
, <a href='nemobench.8.html'>nemobench(8NEMO)</a>

<p>

<p><a href='https://browser.geekbench.com/processor-benchmarks'>https://browser.geekbench.com/processor-benchmarks</a>
 
<p> 
<h2><a name='sect13' href='#toc13'>Author</a></h2>
Peter Teuben 
<p> 
<h2><a name='sect14' href='#toc14'>Files</a></h2>
<br>
<pre>$NEMO/src/scripts/nemo.bench<tt> </tt>&nbsp;<tt> </tt>&nbsp;Script uses by make bench/bench5/bench10
$NEMO/data   <tt> </tt>&nbsp;<tt> </tt>&nbsp;standard repository area for (small) data files.
Benchfile<tt> </tt>&nbsp;<tt> </tt>&nbsp;A Makefile that can orchestrate series of benchmarks
/tmp/nemobench.log<tt> </tt>&nbsp;<tt> </tt>&nbsp;The nemobench keeps logfile
</pre>
<p> 
<h2><a name='sect15' href='#toc15'>Update History</a></h2>
<br>
<pre>12-may-97<tt> </tt>&nbsp;<tt> </tt>&nbsp;created  <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
26-nov-03<tt> </tt>&nbsp;<tt> </tt>&nbsp;finally added some data<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
17-feb-04<tt> </tt>&nbsp;<tt> </tt>&nbsp;added bench0 comparison  <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
31-mar-05<tt> </tt>&nbsp;<tt> </tt>&nbsp;added some cygwin numbers, fixed input<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
6-may-11<tt> </tt>&nbsp;<tt> </tt>&nbsp;added i7 and SHMEM/HDD comparison<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
27-sep-13<tt> </tt>&nbsp;<tt> </tt>&nbsp;added caveats<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
6-jan-2018<tt> </tt>&nbsp;<tt> </tt>&nbsp;updated for V4, more balanced benchmarks <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
27-dec-2019<tt> </tt>&nbsp;<tt> </tt>&nbsp;nemo.bench; updated with potcode and orbint<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
26-jul-2020<tt> </tt>&nbsp;<tt> </tt>&nbsp;added timings / added geekbench5 <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
</pre><p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Bench</a></li>
<li><a name='toc4' href='#sect4'>Nemobench5</a></li>
<li><a name='toc5' href='#sect5'>Bench10</a></li>
<li><a name='toc6' href='#sect6'>Oldest Bench</a></li>
<li><a name='toc7' href='#sect7'>Caveats</a></li>
<li><a name='toc8' href='#sect8'> "others"</a></li>
<li><a name='toc9' href='#sect9'>Tabbench</a></li>
<li><a name='toc10' href='#sect10'>Parallel</a></li>
<li><a name='toc11' href='#sect11'>Considerations</a></li>
<li><a name='toc12' href='#sect12'>See Also</a></li>
<li><a name='toc13' href='#sect13'>Author</a></li>
<li><a name='toc14' href='#sect14'>Files</a></li>
<li><a name='toc15' href='#sect15'>Update History</a></li>
</ul>
</body>
</html>
