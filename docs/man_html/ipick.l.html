  <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>IPICK(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>
               
<h2><a name='sect0' href='#toc0'>Name</a></h2>
ipick - A screen-based filter to <i>i</i>nteractively <i>pick</i>
lines 
<h2><a name='sect1' href='#toc1'>Syntax</a></h2>
<b>ipick</b> [<b>-abdhrRvV</b>] [<b>-m</b> <i>minimum</i>] [<b>-M</b> <i>maximum</i>]   [<b>-t</b> <i>fixed-title-text</i>]
[<b>-T</b> <i>stdin-title-lines</i>]   [<b>-X</b> <i>xterm-name-substring</i>] [<i>filename</i>]<i></i> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
<p>
<i>ipick</i>
reads lines of text from the standard input or the optional <i>filename</i> and
uses <a href='curses.3.html'><i>curses</i>(3)</a>
 to present them as a full-screen selection list. <i>ipick</i> provides
numerous commands to select, navigate, scroll and search through this list.
On quitting, <i>ipick</i> writes the selected lines to the standard output. <p>
Typically
you would use <i>ipick</i> as a final-filter to glue your neat, pre-stored pipelines
and scripts together in a friendly way so that people other than Unix-o-philes
can use them.     <p>
See <b>MOTIVATION</b>, towards the end, for a more detailed discussion.

<h2><a name='sect3' href='#toc3'>Options</a></h2>
<p>
Options can appear in any order so long as they <i>precede</i> the <i>filename</i>.

<dl>

<dt><b>-a</b> </dt>
<dd>Automatically exit when the number of lines selected is within the minimum
and maximum values allowed (see <b>-m</b> and <b>-M</b> options). </dd>

<dt><b>-b</b> </dt>
<dd>Activate the audible
alarm on invalid keystroke commands. Not normally needed as <i>ipick</i> always
generates an error message. Normally you would set this option only for
inexperienced users. </dd>

<dt><b>-d</b> </dt>
<dd>Drain the standard input on exit. This avoids the
possibility of upstream processes receiving a SIGPIPE. This is more a nicety
than a necessity. Furthermore, using this option could prove expensive if
the upstream process is a long way from finishing! </dd>

<dt><b>-h</b>,<b> -?</b> </dt>
<dd>Print an extended
help message describing these options. </dd>

<dt><b>-m</b> </dt>
<dd>Minimum number of lines that the
user must select before <i>ipick</i> will exit. </dd>

<dt><b>-M</b> </dt>
<dd>maximum number of lines that
the user may select select before <i>ipick</i> will exit. </dd>

<dt> You would typically
use the minimum and maximum settings </dt>
<dd>in conjunction with the <b>-a</b> and/or <b>-r</b>
options to ensure an orderly and predictable outcome of the picking process.
</dd>

<dt><b>-r</b> </dt>
<dd>Restricted mode. In this mode the user cannot escape the clutches of <i>ipick</i>
except as defined by the other command-line options. This disables the shell
and pipe commands. Additionally, this disables keyboard signals by setting
the terminal to raw mode instead of cbreak mode. Note that raw mode has
other side-effects; see <a href='stty.1.html'><i>stty</i>(1)</a>
 for more details. </dd>

<dt><b>-R</b> </dt>
<dd>Do not set terminal input
to raw mode. The main effects of this option is that the <a href='stty.1.html'><i>stty</i>(1)</a>
 control
character sequences remain active and are thus capable of generating keyboard
signals such as SIGINT and SIGQUIT. Note that <i>ipick</i> has an abort command
that can be bound to your normal &lsquo;&lsquo;intr&rsquo;&rsquo; or &lsquo;&lsquo;quit&rsquo;&rsquo; characters; see <a href='stty.1.html'><i>stty</i>(1)</a>
 for
more details on raw mode. </dd>

<dt><b>-t</b><i> fixed-title-text</i> </dt>
<dd>Text to use as a title on the
screen. <i>ipick</i> creates a &lsquo;&lsquo;fixed title&rsquo;&rsquo; containing the given text starting at
the top line of the screen. <i>ipick</i> does not scroll this part of the title
horizontally with the data. If the <i>fixed-title-text</i> contains embedded newlines,
<i>ipick</i> handles them correctly. </dd>

<dt><b>-T</b><i> stdin-title-lines</i> </dt>
<dd><i>ipick</i> will read <i>stdin-title-lines</i>
lines from the standard input and use these as the &lsquo;&lsquo;variable title&rsquo;&rsquo; which
follows the &lsquo;&lsquo;fixed title&rsquo;&rsquo;. This option is especially useful when the upstream
process generates a title line, such as <a href='ps.1.html'><i>ps</i>(1)</a>
, or <a href='w.1.html'><i>w</i>(1)</a>
. <i>ipick</i> scrolls this
part of the title horizontally with the data. </dd>

<dt> If the standard input is
less than </dt>
<dd><i>stdin-title-lines</i> long, then <i>ipick</i> terminates silently. </dd>

<dt> If you
define a title with either </dt>
<dd><b>-t</b> or <b>-T</b>, then <i>ipick</i> separates the title from
the data with a line of hyphens. </dd>

<dt><b>-v</b> </dt>
<dd>Invert the selections. With this option,
<i>ipick</i> writes the lines the user <i>did</i> not select to stdout. </dd>

<dt><b>-V</b> </dt>
<dd>Print a message
containing the version, compilation options, location of the system-wide
customization file and the obligatory copyright message. </dd>

<dt><b>-X</b><i> xterm-name-substring</i>
</dt>
<dd><i>ipick</i> compares the <i>xterm-name-substring</i> with the terminal type defined in
$TERM. If it matches, <i>ipick</i> sends the escape sequences needed to enable
and disable mouse-tracking. The default <i>xterm-name-substring</i> is &lsquo;&lsquo;xterm&rsquo;&rsquo;, so real
<a href='xterm.1.html'><i>xterm</i>(1)</a>
 users need do nothing. The comparison is case-sensitive. See <b>XTERM
MOUSE TRACKING</b> for more information. </dd>
</dl>
<p>
The <b>-m</b>, <b>-M</b> and <b>-r</b> options allow you to
carefully control the actions and predict the results of a user. For example,
if you use 
<dl>

<dt> ipick -m 1 -M 1 -r </dt>
<dd></dd>
</dl>
<p>
then you can write the rest of the pipeline
assuming that <i>ipick</i> will produce one and only one line of output. 
<h2><a name='sect4' href='#toc4'>Keyboard
Commands</a></h2>
<p>
<i>ipick</i> accepts numerous keyboard commands, perhaps the most important
being <i>?</i> which provides online help. <p>
<i>ipick</i> is ecumenical regarding keybindings
as it implements a reasonable set of <i>emacs</i>, <i>vi</i> and <i>more</i> keybindings concurrently!
Additionally, <i>ipick</i> binds all of the commonly used commands to function
keys as defined in the TERMINFO (or the corresponding termcap) definition
file. This means that users can avoid learning the idiosyncratic nature
of <i>vi</i> and <i>emacs</i> keystrokes. <p>
Finally, <i>ipick</i> can be customized with both a
system wide startup file and and a user startup file. See <b>CUSTOMIZATION</b>,
for a detailed discussion of these files. For the purposes of this section
it is assumed that no customization is in effect. <p>
The list of keyboard commands
uses the following symbols: 
<dl>

<dt>^A -- control-A </dt>
<dd>Press Control and &lsquo;&lsquo;A&rsquo;&rsquo; together E-A
-- Escape-A Press Escape followed by &lsquo;&lsquo;A&rsquo;&rsquo; </dd>

<dt>K_<i>tttt</i> </dt>
<dd>identifies the TERMINFO (or
termcap) key_<i>tttt</i> used. This is the &lsquo;&lsquo;Variable name&rsquo;&rsquo;, <i>not</i> the &lsquo;&lsquo;Capname&rsquo;&rsquo; in the
man page. </dd>
</dl>
<p>
<i>Selection</i> Commands 
<dl>

<dt>&lt;CR&gt;, K_ent </dt>
<dd>Toggle the selection state of the
current line, then move to the next line if present  </dd>

<dt>0-9 </dt>
<dd>Select the specific
line number </dd>

<dt>S </dt>
<dd>Select all lines </dd>

<dt>C </dt>
<dd>Clear all lines </dd>

<dt>+ </dt>
<dd>Toggle the state of
unread lines </dd>

<dt>s, K_select </dt>
<dd>Select the &lsquo;&lsquo;line-range&rsquo;&rsquo; nominated </dd>

<dt>c, K_clear </dt>
<dd>Clear
the &lsquo;&lsquo;line-range&rsquo;&rsquo; nominated </dd>

<dt>t </dt>
<dd>Toggle the selection state of the &lsquo;&lsquo;line-range&rsquo;&rsquo; nominated
 </dd>
</dl>
<p>
The &lsquo;&lsquo;line-range&rsquo;&rsquo; given to the &lsquo;&lsquo;s&rsquo;&rsquo;, &lsquo;&lsquo;c&rsquo;&rsquo; and &lsquo;&lsquo;t&rsquo;&rsquo; commands may consist of any one
of:  
<ul>
<li>A number, series of numbers or range of numbers <br>
<pre>(e.g. 1 5 7-14 21-19)
</pre></li><li>The string &lsquo;&lsquo;visible&rsquo;&rsquo; meaning all lines currently visible on the screen. </li><li>The
string &lsquo;&lsquo;all&rsquo;&rsquo; meaning all lines.  </li>
</ul>
<p>
You may shorten both &lsquo;&lsquo;visible&rsquo;&rsquo; and &lsquo;&lsquo;all&rsquo;&rsquo; to just
&lsquo;&lsquo;v&rsquo;&rsquo; and &lsquo;&lsquo;a&rsquo;&rsquo; respectively. <i>ipick</i> ignores the case of these strings.  <p>
<i>Positioning</i>
commands 
<dl>

<dt> T, K_beg </dt>
<dd>Top of File </dd>

<dt>B, K_end </dt>
<dd>Bottom of File </dd>

<dt>H, K_home </dt>
<dd>Top of
screen </dd>

<dt>L, K_ll </dt>
<dd>Bottom of screen </dd>

<dt>^N, j, K_down </dt>
<dd>Next line </dd>

<dt>^P, k, K_up </dt>
<dd>Previous
line  </dd>
</dl>
<p>
<i>Vertical</i> scrolling 
<dl>

<dt>^U </dt>
<dd>Up half the screen  </dd>

<dt>^D </dt>
<dd>Down half the screen </dd>

<dt>E-v,
b, K_ppage, K_rindex </dt>
<dd>Up full screen </dd>

<dt>^V, &lt;Space&gt;, K_npage, K_index </dt>
<dd>Down full
screen  </dd>
</dl>
<p>
<i>Horizontal</i> scrolling 
<dl>

<dt>^B, h, K_left </dt>
<dd>Scroll left one character  </dd>

<dt>^F,
l, K_right </dt>
<dd>Scroll right one character </dd>

<dt>^I (TAB) </dt>
<dd>Scroll right one tabstop
</dd>

<dt>E-i, K_cbt </dt>
<dd>Scroll left one tabstop </dd>

<dt>^A, ^ (circumflex) </dt>
<dd>Scroll to beginning
of line </dd>

<dt>^E, $ </dt>
<dd>Scroll to end of line </dd>

<dt>&lt; </dt>
<dd>Scroll left half screen </dd>

<dt>&gt; </dt>
<dd>Scroll right
half screen  </dd>
</dl>
<p>
<i>Searching</i> 
<dl>

<dt>^S, E-s, /, K_find </dt>
<dd>Forward search  </dd>

<dt>^R, E-r, \ </dt>
<dd>Reverse
search </dd>

<dt>n </dt>
<dd>Redo forward search </dd>

<dt>N </dt>
<dd>Redo reverse search </dd>

<dt>*, K_next </dt>
<dd>Find next
selected line </dd>

<dt>&amp;, K_prev </dt>
<dd>Find previous selected line  </dd>
</dl>
<p>
<i>Miscellaneous</i> 
<ul>
.<li>Redo
last command  </dd>

<dt>g, K_move </dt>
<dd>Go to line </dd>

<dt>q, Q, ^X^C, ZZ, K_exit </dt>
<dd>Quit </dd>

<dt>^C </dt>
<dd>Abort </dd>

<dt>^L,
K_refresh </dt>
<dd>Refresh </dd>

<dt>?, K_help </dt>
<dd>Provide online help </dd>

<dt>! </dt>
<dd>Shell command </dd>

<dt>| </dt>
<dd>Pipe command.
Pipe the current line into the command  </dd>
</dl>

<h2><a name='sect5' href='#toc5'>Customization</a></h2>
<p>
When <i>ipick</i> is invoked,
it reads initialization commands from the site customization file (normally
/usr/local/lib/ipickrc but see the <b>-V</b> option) and then the user&rsquo;s customization
file .ipickrc in the user&rsquo;s home directory. Both files are optional. The file
can contain blank lines and comments where comments are denoted by the
first occurence of the &lsquo;&lsquo;#&rsquo;&rsquo; character. <p>
A command must be completely contained
on a single line as there is no continuation character. Each token can be
separated by one or more white-space characters. A token can be quoted if
it requires embedded spaces with either a single or double quote. <p>
 <i>Substitution</i>
sequences <p>
The following special substitution sequences are recognized:

<dl>

<dt><i></i><b>\b</b> </dt>
<dd>A backspace character </dd>

<dt><b>\f</b> </dt>
<dd>A form-feed </dd>

<dt><b>\e</b> </dt>
<dd>An escape </dd>

<dt><b>\n</b> </dt>
<dd>The newline character
</dd>

<dt><b>\r</b> </dt>
<dd>A carriage-return </dd>

<dt><b>\s</b> </dt>
<dd>A space </dd>

<dt><b>\t</b> </dt>
<dd>A TAB </dd>

<dt><b>\\</b> </dt>
<dd>The back-slash character </dd>

<dt><b>\NNN</b> </dt>
<dd>The character
represented by the  octal value of <i>NNN</i> </dd>

<dt><b>^char</b> </dt>
<dd>A control character. <i>char</i> can
be &lsquo;&lsquo;A-Z&rsquo;&rsquo; or &lsquo;&lsquo;@&rsquo;&rsquo;. </dd>
</dl>
<p>
<i>Customization</i> commands   <p>
<b>bind-key</b> <i>function</i> <i>keysequence</i> [<i>helptext</i>]<i></i>

<dl>

<dt> Bind a set of keystrokes to a specific function. </dt>
<dd></dd>
</dl>
<p>
<b>bind-terminfo</b> <i>function</i>
<i>terminfo-capability</i> [<i>helptext</i>]<i></i> 
<dl>

<dt> Bind a terminfo capability to a specific
</dt>
<dd>function. If the terminfo functionality has not been built into <i>ipick</i> then
this effectively becomes a no-op. </dd>
</dl>
<p>
<b>bind-termcap</b> <i>function</i> <i>termcap-capability</i>
[<i>helptext</i>]<i></i> 
<dl>

<dt> Bind a termcap capability to a specific </dt>
<dd>function. If the termcap
functionality has not been built into <i>ipick</i> then this effectively becomes
a no-op. </dd>
</dl>
<p>
<b>include</b> <i>includefile</i> <p>
Where: <p>

<dl>

<dt><i></i><i>function</i> </dt>
<dd>is a valid <i>ipick</i> function; see
<b>FUNCTIONS</b>, for a complete list. </dd>

<dt><i>keysequence</i> </dt>
<dd>is any sequence of keystrokes.
The <i>substitution</i> character will typically be useful for this parameter.
</dd>

<dt><i>helptext</i> </dt>
<dd>is an optional text string that will be displayed as part of the
online help screen. If not present then the keysequence or capability name
will be used. </dd>

<dt><i>terminfo-capability</i> </dt>
<dd>A valid terminfo keystroke capability name;
see <a href='terminfo.5.html'><i>terminfo</i>(5)</a>
 for more details. </dd>

<dt><i>termcap-capability</i> </dt>
<dd>A valid termcap keystroke
capability name; see <a href='termcap.5.html'><i>termcap</i>(5)</a>
 for more details. </dd>

<dt><i>includefile</i> </dt>
<dd>a path of
the file to include. </dd>

<dt> If </dt>
<dd><i>includefile</i> has a leading tilde &lsquo;&lsquo;~&rsquo;&rsquo; then <i>ipick</i> performs
the usual tilde expansion. That is the string between the tilde and the
first &lsquo;&lsquo;/&rsquo;&rsquo; character is treated as a login name whose home directory is substituted.
An empty login name implies $HOME. </dd>

<dt> If </dt>
<dd><i>includefile</i> contains any shell characters
then <i>ipick</i> assumes that it&rsquo;s a pipeline command and uses <a href='popen.3S.html'><i>popen</i>(3S)</a>
 rather
than <a href='fopen.3V.html'><i>fopen</i>(3V)</a>
 to open the command. </dd>

<dt> If </dt>
<dd><i>includefile</i> is treated as a pipeline
command and there is no trailing pipe character &lsquo;&lsquo;|&rsquo;&rsquo; then <i>ipick</i> preceeds the
pipeline string with the <a href='cat.1.html'><i>cat</i>(1)</a>
 command.  </dd>
</dl>
<p>
The follow sample <i>.ipickrc</i> file
demostrates most of the functionality discuss in this section. <p>
<br>
<pre>#
# This file has some comments in it
#
include "~fred/.ipickrc"         # Fred has a cool startup file
include &rsquo;/usr/local/lib/ipick_${EDITOR:-EMACS}&rsquo;
include "grep terminfo /usr/local/lib/ipick_wyse |"
include "$HOME/env/test_bindings"
bind-key QUIT "\e\s\023" "NT250 Exit key"
# Bind the begining of line terminal definition
bind-terminfo beginning-of-line kbeg
bind-termcap beginning-of-line @1
</pre>
<h2><a name='sect6' href='#toc6'>Functions</a></h2>
The follow is a list of available functions. <p>

<dl>

<dt><i></i><i>select-range</i> </dt>
<dd>Enter
a range of line numbers to pick </dd>

<dt><i>select-all</i> </dt>
<dd>Mark all lines as picked </dd>

<dt><i>clear-range</i>
</dt>
<dd>Enter a range of line numbers which are to have their pick state cleared
</dd>

<dt><i>clear-all</i> </dt>
<dd>Mark all lines as not picked </dd>

<dt><i>toggle-current</i> </dt>
<dd>Toggle the picked state
of the current line and move the cursor to the next line </dd>

<dt><i>toggle-range</i> </dt>
<dd>Enter
a range of line numbers which are to have their pick state toggled </dd>

<dt><i>toggle-unread</i>
</dt>
<dd>Toggle the picked state of all unread lines </dd>

<dt><i>top-of-screen</i> </dt>
<dd>Move the cursor
to the top of the screen </dd>

<dt><i>bottom-of-screen</i> </dt>
<dd>Move the cursor to the bottom of
the screen </dd>

<dt><i>previous-line</i> </dt>
<dd>Move the cursor up one line </dd>

<dt><i>next-line</i> </dt>
<dd>Move the cursor
down one line </dd>

<dt><i>quit</i> </dt>
<dd>Exit and write the pick lines to stdout </dd>

<dt><i>abort</i> </dt>
<dd>Exit without
writing anything to stdout </dd>

<dt><i>help</i> </dt>
<dd>Display the online help screen </dd>

<dt><i>refresh</i>
</dt>
<dd>Clear and re-display the current screen </dd>

<dt><i>scroll-left-char</i> </dt>
<dd>Move the cursor left
one position </dd>

<dt><i>scroll-right-char</i> </dt>
<dd>Move the cursor right one position </dd>

<dt><i>beginning-of-line</i>
</dt>
<dd>Move the cursor to the first character position </dd>

<dt><i>end-of-line</i> </dt>
<dd>Move the cursor
to the last character position of the current line </dd>

<dt><i>scroll-tab</i> </dt>
<dd>Move the cursor
forward one tabstop </dd>

<dt><i>scroll-backtab</i> </dt>
<dd>Move the cursor back one tabstop </dd>

<dt><i>scroll-left-screen</i>
</dt>
<dd>Move the cursor left by one half the width of the screen </dd>

<dt><i>scroll-right-screen</i>
</dt>
<dd>Move the cursor right by one half the width of the screen </dd>

<dt><i>scroll-up-half</i>
</dt>
<dd>Move the cursor up by one half of the height of the screen </dd>

<dt><i>scroll-down-half</i>
</dt>
<dd>Move the cursor down by one half of the height of the screen </dd>

<dt><i>scroll-up-full</i>
</dt>
<dd>Move the cursor up a full screen </dd>

<dt><i>scroll-down-full</i> </dt>
<dd>Move the cursor down a
full screen </dd>

<dt><i>beginning-of-file</i> </dt>
<dd>Move the cursor to the first line </dd>

<dt><i>end-of-file</i>
</dt>
<dd>Move the cursor to the end of all the input lines. If data is from an upstream
process, ipick will read until this process writes end of file </dd>

<dt><i>search-forward</i>
</dt>
<dd>Enter the search forward string </dd>

<dt><i>search-backward</i> </dt>
<dd>Enter the reverse search
string </dd>

<dt><i>re-search-forward</i> </dt>
<dd>Continue the search forwards </dd>

<dt><i>re-search-backward</i> </dt>
<dd>Continue
the search backwards </dd>

<dt><i>next-selected</i> </dt>
<dd>Move the cursor to the next line selected
</dd>

<dt><i>previous-selected</i> </dt>
<dd>Move the cursor to the previous line selected </dd>

<dt><i>goto-line</i>
</dt>
<dd>Enter a line number to position to </dd>

<dt><i>shell</i> </dt>
<dd>Enter a shell command </dd>

<dt><i>pipe</i> </dt>
<dd>Enter
a  command which will have the current line written to it&rsquo;s stdin </dd>

<dt><i>redo-command</i>
</dt>
<dd>Redo the last command </dd>

<dt><i>xterm-mouse</i> </dt>
<dd>Define the xterm escape prefix. Only to
be used if you really know what you&rsquo;re doing (Which I don&rsquo;t when it comes
to <a href='nroff.1.html'><i>nroff</i>(1)</a>
) </dd>

<dt><i>invalid-command</i> </dt>
<dd>Treat as an invalid command and generate an
error message </dd>
</dl>

<h2><a name='sect7' href='#toc7'>Xterm Mouse Tracking</a></h2>
<p>
<i>ipick</i> has limited support for <i>xterm</i>&rsquo;s
&lsquo;&lsquo;mouse tracking&rsquo;&rsquo; capability (the X11 &lsquo;&lsquo;normal tracking mode&rsquo;&rsquo; not the X10 compatibility
mode). <p>
To enable this facility in a particular <i>xterm</i> you have to send it
a special escape sequence. To quote from <a href='xterm.1.html'><i>xterm</i>(1)</a>
, &lsquo;&lsquo;[mouse tracking] is enabled
by specifying parameter 1000 to DECSET&rsquo;&rsquo;. <i>ipick</i> does this automatically when
it detects a terminal type of <i>xterm</i>. If your <i>xterm</i> clone uses a different
name, you can use the <b>-X</b> option to tell ipick what it is. <p>
When you enable
this facility, your <i>xterm</i> will pass any mouse events to <i>ipick</i> in a form
that <i>ipick</i> recognizes. In all cases, the down event defines the start of
a range of lines and the up event defines the end of the range -- so dragging
is useful. <p>
Each mouse button has the following function: 
<dl>

<dt><b>Button</b> </dt>
<dd><b>Description</b>
</li><li>Set the selected status of the range  </li><li>Toggle the selected status of the
range </li><li>Clear the selected status of the range  </li>
</ol>
<p>
Note that <i>ipick</i> ignores augmentation
of mouse events with the Shift, Control and Meta keys. <p>
The <i>xterm</i> facility
is limited in that chording the mouse buttons seems to be undefined. Furthermore,
the release (or mouse-up) doesn&rsquo;t specify the button. Accordingly <i>ipick</i> takes
a conservative approach to mouse-events and tends to discard anything unexpected.
 
<h2><a name='sect8' href='#toc8'>Diagnostics</a></h2>
All error messages should be self-explanatory. <p>
<i>Exit</i> codes. 
<ol>
<li>Normal
termination -- at least one line selected </li><li>Normal termination -- no lines selected
</li><li>Abnormal termination </li>
</ol>

<h2><a name='sect9' href='#toc9'>Notes</a></h2>
<p>
If no input exists, or if the <b>-T</b> option causes
<i>ipick</i> to consume all its input, then <i>ipick</i> terminates silently with an
exit code of 1. <p>
Each Newline terminated string in <i>fixed-title-text</i> (see the
<b>-t</b> option) becomes a separate line on the fixed-title section of the screen.
<p>
<i>ipick</i> only reads lines from the standard input as needed (and after each
keyboard command) rather than reading all input lines on starting. This
is especially useful if the upstream process generates output lines slowly
as <i>ipick</i> is able to display lines as soon as they become available -- within
the constraints of any buffering. It is also useful if the upstream process
has the potential to generate an enormous number of lines of output prior
to completion. <p>
<i>ipick</i> processes binary files correctly, but it&rsquo;s hard to imagine
that this capability is especially useful. <p>
When constructing pipelines,
be aware of the fact that many commands don&rsquo;t take multiple parameters. In
these cases, use xargs -l1 if your system has it. 
<h2><a name='sect10' href='#toc10'>Restrictions</a></h2>
<p>
<i>ipick</i> is designed
to process modest amounts of data. The data is held in memory and all functions
are coded simplistically. If you ask <i>ipick</i> to handle large amounts of data,
it does so sluggishly and consumes excessive system resources. <p>
<i>ipick</i> takes
a passive approach to ambiguous function key definitions -- later definitions
override earlier definitions. <p>
The search function does not handle regular
expressions. <p>
Because of the way in which <i>ipick</i> reads the standard input,
using <i>ipick</i> with data from the keyboard does not work as you would want
(In fact <i>ipick</i> should probably insist on a pipe or a file as input, just
as <i>more</i> does). The workaround is to use the &lsquo;&lsquo;here document&rsquo;&rsquo; capability of
the shell (the &lsquo;&lsquo;&lt;&lt;&rsquo;&rsquo; redirection). <p>
<i>ipick</i> arbitrarily expands tab characters to
8-column tabstops. 
<h2><a name='sect11' href='#toc11'>Bugs</a></h2>
<p>
The online help does not display properly if the screen
is less than 80 columns wide. <p>
Directions implied by movement and scrolling
commands apply to the cursor, not the data. <p>
<i>ipick</i> does not know when include
files opened with <a href='popen.1.html'><i>popen</i>(1)</a>
 fail. This can sometimes cause <i>ipick</i> to wait
for ever depending on the state of the child process. 
<h2><a name='sect12' href='#toc12'>Motivation</a></h2>
<p>
It is the
very essence of Unix to make useful commands with the generic construct:

<dl>

<dt>generate_listing | </dt>
<dd><i>FILTER</i> | do_something  </dd>
</dl>
<p>
or 
<dl>

<dt>do_something &lsquo;generate_listing
| </dt>
<dd><i>FILTER</i>&lsquo;  </dd>
</dl>
<p>
The problem is <i>FILTER</i>. Getting it correct for the simplistic case
is easy, making it perfect and bullet-proof is not. This is especially true
if the pipeline is being developed for the user community. <p>
Think about how
you typically build a pipeline for the following requests: 
<dl>

<dt>&lsquo;&lsquo;Kill my awk
process, it&rsquo;s hung my terminal.&rsquo;&rsquo; </dt>
<dd><br>
&lsquo;&lsquo;Remove my print job, I&rsquo;ve run the wrong report.&rsquo;&rsquo; <br>
&lsquo;&lsquo;Remove that message queue, then re-run the daemon.&rsquo;&rsquo; </dd>
</dl>
<p>
Either you construct a
nice obscure <i>FILTER</i> using some combination of <a href='grep.1.html'><i>grep</i>(1)</a>
, <a href='awk.1.html'><i>awk</i>(1)</a>
, <a href='perl.1.html'><i>perl</i>(1)</a>
,
or <a href='sed.1.html'><i>sed</i>(1)</a>
 -- usually after you&rsquo;ve had a look at the <i>generate_listing</i> output
a couple of times to make sure you don&rsquo;t zap the wrong thing! Alternatively
you run the <i>generate_listing</i> program a couple of times until you&rsquo;ve memorized
the relevant identifier (such as pid, job number, queue id), then you run
the <i>do_something</i> program and re-type the relevant identifier trying as best
you can to avoid mis-typing and mis-remembering. <p>
In other words, tedious and
error-prone. <p>
Of course, when the time comes to give your neat pipeline or
script to the user community, how do you give it an easy to use, safe,
bullet-proof interface? Do you knock up a quick shell wrapper with token
prompts, perfunctory checking and an interface that&rsquo;s <i>almost</i> the same as
your last shell wrapper? <p>
If any of these situations sound familiar then
<i>ipick</i> may well be your pipeline panacea! (Well, at least marginally useful.)
<p>
This is because <i>ipick</i> makes the user the final part of the <i>FILTER</i> in a
safe, friendly manner, often obviating the need for shell wrappers and
such. <p>
The example of selecting and removing a set of print jobs is the easiest
way to demonstrate <i>ipick</i>. With the pipeline: <br>
<pre>
</pre><p>

<dl>

<dt>lpq | grep &lsquo;whoami&lsquo; | ipick | awk &rsquo;{ print $3 }&rsquo; | xargs lprmYou use </dt>
<dd><i>ipick</i> to select
the print jobs to be removed and the pipeline does the rest, removing only
those print jobs selected with <i>ipick</i>. Another example: <br>
<pre>
</pre></dd>
</dl>
<p>

<dl>

<dt>kill -9 &lsquo;ps | ipick -T1 | awk &rsquo;{ print $1 }&rsquo;&lsquo;you simply select the lines with the
relevant pids then </dt>
<dd>exit from <i>ipick</i> -- the pipeline does the rest by killing
only those processes you selected with <i>ipick</i>. </dd>
</dl>

<h2><a name='sect13' href='#toc13'>Examples</a></h2>
<p>
A few more examples
to get you started. Normally you would define each of these as a function
or alias in your shell. (Of course, I present these examples as ideas. They
are not complete, bullet-proof functions.) <p>
<i>Pick source files to edit.</i> <br>
<pre>
</pre><p>

<dl>

<dt>vi &lsquo;ls -1 *.c | ipick -m1&lsquo;<i>Pick a directory to cd to.</i> </dt>
<dd><br>
<pre>
</pre></dd>
</dl>
<p>

<dl>

<dt>cd &lsquo;ls -l | grep &rsquo;^d&rsquo; | ipick -m1 -M1 -a | cut -c46-&lsquo; </dt>
<dd><i>Pick files to extract from a tar
file in the default tape drive.</i> <br>
<pre>
</pre></dd>
</dl>
<p>

<dl>

<dt>tar t | ipick | xargs tar xvI find this especially useful when the archive
</dt>
<dd>contains l-o-o-o-ng filenames. </dd>
</dl>
<p>
Actually, in its current form the above example
has a number of limitations, so a more complete solution to an interactive
tar is: <br>
<pre>


</pre>
<dl>

<dt><p>
tar tvf ${1:-/dev/rmt8} | sed -e &rsquo;s./$..&rsquo; | ipick |<tt> </tt>&nbsp;<tt> </tt>&nbsp;cut -c42- | xargs -v -t tar xvf ${1:-/dev/rmt8}
{} </dt>
<dd></dd>
</dl>
<p>
<i>Clean up a directory containing many junk files.</i> <p>
The following pipeline
does this by letting you select the files you want to keep, and deleting
the rest. <br>
<pre>


</pre>
<dl>

<dt><p>
rm &lsquo;ls -l | grep &rsquo;^-&rsquo; | ipick -v -t "Which files to keep ?" |<tt> </tt>&nbsp;<tt> </tt>&nbsp;cut -c46-&lsquo; </dt>
<dd></dd>
</dl>
<p>
 <i>Part of the
login script to set the terminal type</i> <br>
<pre>














</pre>
<dl>

<dt><p>
#! /bin/sh...export TERMTERM=&lsquo;ipick -m1 -M1 -r -a -T3 &lt;&lt;EOD | cut -f1 -d&rsquo; &rsquo;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Pick the terminal
type that you are logged intovt100<tt> </tt>&nbsp;<tt> </tt>&nbsp;The old grey terminals in the conference
roomxterm<tt> </tt>&nbsp;<tt> </tt>&nbsp;The new fancy terminals in the bosses officesun<tt> </tt>&nbsp;<tt> </tt>&nbsp;One of the workstations
in the sysadmin&rsquo;s office!EOD&lsquo;... </dt>
<dd></dd>
</dl>
<p>
<i>Site conventions for predefined files</i> <p>
If you
get really keen, you can have a site convention for all pre-defined <i>ipick</i>
files, such as: 
<ul>
<li>first two lines are always header </li><li>first space separated
field is always the output selection value </li>
</ul>
<p>
Then you can define a generic
function or script (let&rsquo;s call it ipickf) such as: <br>
<pre>
</pre><p>

<dl>

<dt>ipick -a -m1 -M1 -r -T2 $HOME/pickfiles/$1 | cut -f1 -d&rsquo; &rsquo;then use it around the
traps as: </dt>
<dd><br>
<pre>
</pre></dd>
</dl>
<p>

<h2><a name='sect14' href='#toc14'>TERM=&lsquo;ipickf TERM&lsquo;Version</a></h2>
<p>

<dl>

<dt><i>ipick</i> </dt>
<dd>version 1.1, dated 28 February, 1993. </dd>
</dl>

<h2><a name='sect15' href='#toc15'>Author</a></h2>
<p>
Copyright
(c) 1993, Mark Delany &lt;markd@werple.apana.org.au&gt; All rights reserved. <p>
Substantial
man page improvements by DaviD W. Sanderson &lt;dws@ssec.wisc.edu&gt; <p>
<i>ipick</i> may only
be copied under the terms of either the Artistic License or the GNU General
Public Licence, which may be found in the ipick source kit. 
<h2><a name='sect16' href='#toc16'>See Also</a></h2>
<a href='stty.1.html'><i>stty</i>(1)</a>
,
<a href='xargs.1V.html'><i>xargs</i>(1V)</a>
, <a href='xterm.1L.html'><i>xterm</i>(1L)</a>
, <a href='curses.3V.html'><i>curses</i>(3V)</a>
, <a href='terminfo.5.html'><i>terminfo</i>(5)</a>
, <a href='termcap.5.html'><i>termcap</i>(5)</a>
 <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Syntax</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<li><a name='toc4' href='#sect4'>Keyboard Commands</a></li>
<li><a name='toc5' href='#sect5'>Customization</a></li>
<li><a name='toc6' href='#sect6'>Functions</a></li>
<li><a name='toc7' href='#sect7'>Xterm Mouse Tracking</a></li>
<li><a name='toc8' href='#sect8'>Diagnostics</a></li>
<li><a name='toc9' href='#sect9'>Notes</a></li>
<li><a name='toc10' href='#sect10'>Restrictions</a></li>
<li><a name='toc11' href='#sect11'>Bugs</a></li>
<li><a name='toc12' href='#sect12'>Motivation</a></li>
<li><a name='toc13' href='#sect13'>Examples</a></li>
<li><a name='toc14' href='#sect14'>TERM=`ipickf TERM`Version</a></li>
<li><a name='toc15' href='#sect15'>Author</a></li>
<li><a name='toc16' href='#sect16'>See Also</a></li>
</ul>
</body>
</html>
