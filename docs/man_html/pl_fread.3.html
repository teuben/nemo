<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>AXIS(3NEMO) manual page</title>
</head>
<body bgcolor='white'>
HTML automatically generated with <A HREF=http://manpages.ubuntu.com/manpages/bionic/man1/rman.1.html>rman</A><br>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
pl_fread, pl_lread, pl_exec - ASCII interpreter of YAPP commands 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<br>
<pre>#include &lt;layout.h&gt;
plcommand *pl_fread(string filename)
int pl_lread(string line, plcommand *p)
void pl_exec(plcommand *p)
void pl_readlines(void);

</pre>
<h2><a name='sect2' href='#toc2'>Description</a></h2>
The <a href='layout.3.html'><i>layout(3NEMO)</i></a>
 routines proved the programmer with an ASCII
interpreter and executionar of all basic <a href='yapp.3.html'><i>yapp(3NEMO)</i></a>
 routines (see <a href='layout.5.html'><i>layout(5NEMO)</i></a>

for a listing). They are mostly used to add a standard &lsquo;&lsquo;background&rsquo;&rsquo; to a dynamic
picture, yet which needs to be programmable by the outside user. <p>
With the
routine <i>pl_fread</i> a <a href='layout.5.html'><i>layout(5NEMO)</i></a>
 (regular text)  file is read, it&rsquo;s YAPP
commands are interpreted and placed in a linked list of <b>plcommand</b>&rsquo;s, returned
as a pointer to that structure. Commands that are not understood are skipped
and not saved. <p>
The routine <i>pl_lread</i> reads a single line, parses it in YAPP
commands, and stores the encoded command in the <b>plcommand</b> structure pointed
to by <b>p</b>.  Of course <i>pl_fread</i> calls <i>pl_lread</i> to do its work. <i>pl_lread</i> returns
the number of arguments (including the YAPP command); 0 means no legal
command (or a blank line)  was encountered and the structures contents
have no meaning. <p>
The routine <i>pl_exec</i> executes a previously read LAYOUT file,
by passing it a pointer to the linked list of <b>plcommand</b>. The linked list
is traversed until it ends or the <i>End</i> command is encountered. <p>
The routine
<i>pl_readlines</i> keeps reading commands from stdin (via the READLINE library
if present) and executing them, in effect giving a simple mongo/sm/wip
type interface. 
<h2><a name='sect3' href='#toc3'>Examples</a></h2>
The following code reads a layout file entered through
a program keyword <b>layout=</b>, parses it and executes it. Because of the nested
programming style, the linked list of <b>plcommand</b> is lost. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;pl_exec(pl_fread(getparam("layout")));
</pre>
<h2><a name='sect4' href='#toc4'>See Also</a></h2>
<a href='tabplot.1.html'>tabplot(1NEMO)</a>
, <a href='yapp.3.html'>yapp(3NEMO)</a>
, <a href='layout.5.html'>layout(5NEMO)</a>
 
<h2><a name='sect5' href='#toc5'>Author</a></h2>
Peter Teuben 
<h2><a name='sect6' href='#toc6'>Update
History</a></h2>
<br>
<pre>20-oct-92 <tt> </tt>&nbsp;<tt> </tt>&nbsp;written          <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
17-sep-05<tt> </tt>&nbsp;<tt> </tt>&nbsp;added pl_readlines<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
</pre> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Examples</a></li>
<li><a name='toc4' href='#sect4'>See Also</a></li>
<li><a name='toc5' href='#sect5'>Author</a></li>
<li><a name='toc6' href='#sect6'>Update History</a></li>
</ul>
</body>
</html>
