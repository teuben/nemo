<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>UNFIO(3NEMO) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
unfscan, unfread, unfwrite, unfswap, unfsize - unformatted FORTRAN I/O
data access from C 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<br>
<pre>#include &lt;stdinc.h&gt;#include &lt;unfio.h&gt;int unfscan(stream instr)
int unfread(stream instr, char *buf, int bufsize)
int unfwrite(stream instr, char *buf, int bufsize)
int unfswap(bool do_swap)
int unfsize(int size)


Descriptionunfio are a set of routines that allow you to (sequentially)
access  binary files that have been created with most FORTRAN compilers
 in unformatted I/O access. The datafile should have been created with an
form=&rsquo;unformatted&rsquo; OPEN statement. unfscan can be used to scan unformatted
records, returning the size (in bytes) of the data-section of each record.
End of file and various others  errors are returned as 0 and some negative
number resp.  unfread can be used in the same way, except you give it a
buffer in which the data can be stored. In good old fortran tradition you
must know the largest buffer size this routine can expect to see. unfwrite
is the opposite of read. The unfsize routine can be set to change the default
UNFIO_HDR_SIZE header size (as determined during NEMO configure and install).
Most older compilers use 4, whereas gfortran use 8. There is also suppor
for 0, which means pure headerless raw data can be read this way. 
For example,
the file created from the following snippet of code 

        INTEGER unit,n
        REAL x,y(3),z(n)
        OPEN(unit,file=&rsquo;test.dat&rsquo;,form=&rsquo;unformatted&rsquo;)
        WRITE(unit) n
        WRITE(unit) x,y,z
        CLOSE(unit)
</pre>can be read with the following snippet of C code: <br>
<pre>        char buf[MAXBUF];
        int *ip = (int *) buf;
        float *fp = (float *) buf;
        double *dp = (double *) buf;
        int n;
        float x, y[3], z[MAXN];
        instr = stropen(...,"r");
        count = unfread(instr,buf,MAXBUF);
        if (count &lt; 1) error("first block");
        n = ip[0];
        count = unfread(instr,buf,MAXBUF);
        if (count &lt; 1) error("second block");
        x = fp[0];
        y[0] = fp[1]; y[1] = fp[2]; y[2] = fp[3];
        for (i=0; i&lt;n; i++)
            z[i] = fp[4+i];
        strclose(instr);
</pre>
<h2><a name='sect3' href='#toc3'>Limitations</a></h2>
Currently only tested on a limited number of machines (SunOS,
HP/UX), or any machine where  <i>unformatted</i> binary output surrounds the data
with 4 bytes designating the size of the data written, i.e. what  a single
WRITE statement block writes to disk can be represented as: <br>
<pre>    struct block {
        int size;
        char buf[size];
        int size;
    } block
</pre><p>
Access is sequential. If the user keeps a record of the file pointer, and
knows the low level filestructure is that of <i>block</i> described above, a call
to <a href='fseek.3.html'><i>fseek(3)</i></a>
 can in principle be used to re-read previous blocks. 
<h2><a name='sect4' href='#toc4'>Bugs</a></h2>
Alignment
restrictions on some architectures (e.g. sparc) may  make reading certain
datafiles hard. This feature has not been implemented. It is up to the user
to define their data-alignment structures/unions, or perform the necessary
data copy before casting is attempted. 
<h2><a name='sect5' href='#toc5'>See Also</a></h2>
<a href='filestruct.5.html'>filestruct(5NEMO)</a>
 
<h2><a name='sect6' href='#toc6'>Author</a></h2>
Peter
Teuben 
<h2><a name='sect7' href='#toc7'>Files</a></h2>
<br>
<pre>~/src/fortran/  <tt> </tt>&nbsp;<tt> </tt>&nbsp;unfio.c
</pre>
<h2><a name='sect8' href='#toc8'>Update History</a></h2>
<br>
<pre>xx-may-94<tt> </tt>&nbsp;<tt> </tt>&nbsp;V1.0 Created for prun       <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
8-aug-95<tt> </tt>&nbsp;<tt> </tt>&nbsp;V1.1 added support for swap for NBODY5 (u3tos)<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
1-mar-06<tt> </tt>&nbsp;<tt> </tt>&nbsp;V1.2 added unfsize for gfortran <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
4-mar-06<tt> </tt>&nbsp;<tt> </tt>&nbsp;V1.3 use a default UNFIO_HDR_SIZE for hdr_size<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
8-may-08<tt> </tt>&nbsp;<tt> </tt>&nbsp;V1.4 support raw header=0 data<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
25-feb-09<tt> </tt>&nbsp;<tt> </tt>&nbsp;V1.5 add non-swapping version of unfwrite<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
</pre>
<p>  <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Limitations</a></li>
<li><a name='toc4' href='#sect4'>Bugs</a></li>
<li><a name='toc5' href='#sect5'>See Also</a></li>
<li><a name='toc6' href='#sect6'>Author</a></li>
<li><a name='toc7' href='#sect7'>Files</a></li>
<li><a name='toc8' href='#sect8'>Update History</a></li>
</ul>
</body>
</html>
