   <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>NEWTON0(1NEMO) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
newton0, newton0tree, newton0reg - nbody codes with equal time steps

<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>newton0</b> [<b>in=</b>infile] [<b>lastout=</b>lastoutfile] [<b>out=</b>outfile] [<b>save=</b>savefile]
[<b>restore=</b>restorefile] [<b>resume=</b>resumefile] [<b>restart=</b>restartfile] [<b>nbody=</b>integer]
[<b>seed=</b>integer] [<b>t_begin=</b>real] [<b>t_end=</b>real] [<b>dt_minor=</b>real] [<b>dt_major=</b>real]
[<b>dt_save=</b>real] [<b>dt_max=</b>real] [<b>nstep=</b>integer] [<b>min_pairdist=</b>real] [<b>de_max=</b>real]
[<b>nstep_de=</b>integer] [<b>cpu_max=</b>real] [<b>cpu_last_call=</b>real] [<b>eta_acc=</b>real] [<b>r0_soft=</b>real]
[<b>soft_focus=</b>softeningtype] [<b>timestep=</b>timestepcriterion] [<b>diagnostics=</b>diagnosticstype]
[<b>scheme=</b>integrationscheme] [<b>headline=</b>string] 
<p> <b>newton0tree</b> [...same as in newton0...]
[<b>tol=</b>real] [<b>celldivision=</b>celldivisionmethod] 
<p> <b>newton0reg</b> [...same as in newton0...]
[<b>niter=</b>integer] 
<p> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>

<p> <i>newton0</i> is a simple type of gravitational
many-body code: simple in the sense of giving all particles equal time steps
at any given time (although the length of this shared time step does change
in time in an adaptive fashion; see below). Apart from this limitation the
code is rather flexible: it gives a choice of a number of integration schemes
which can be invoked on the command line; a choice of various softening
procedures; a choice of time step criterion; a choice of diagnostics provided
during the run; and it has a wide choice of start-up options, from a snapshot,
or a previously saved system state, or from scratch in which case newton0
produces a Plummer model. 
<p> <i>newton0tree</i> is an extension to <i>newton0</i> in which
a hierarchical force calculation is performed using an adaptive Eulerian
tree scheme (J. Barnes and P. Hut 1986, <i>Nature <b>324</b></i>, 446), which reduces the
number of pairwise force calculations per timestep from order #N sup 2#
to order #N log N# . 
<p> <i>newton0reg</i> is an extension to <i>newton0</i> in which a full
pairwise regularization scheme is implemented, based on the Kustaanheimo_Stiefel
four-dimensional regularization, as generalized by D.C. Heggie, <i>Celestial
Mechanics <b>10</b></i>, 217 (1974); and implemented following the recipes given by
S. Mikkola, <i> Mon. Not. R. astr. Soc.  <b>215</b></i>, 171 (1985). The order of the system
of equations is raised from the usual #6 N# to #4N(N-1)+1#. 
<p> The code has
been written in a highly structured, modular and flexible way (see the
<i>Newton0 Primer</i>). It can thus serve as a blueprint for more advanced gravitational
many-body integration modules.  Its generality makes it suitable for experimentation
with different integration, softening, timestep and diagnostics schemes.
 When using <i>newton0</i> in production runs it may be advisable to throw out
some of the unneeded embellishments, and to optimize the inner loops -- but
remember: <i>premature optimization is the root of all evil</i> (or at least of
most).   
<h2><a name='sect3' href='#toc3'>Parameters</a></h2>
The following parameters are recognized; they may be
given in any order. 
<dl>

<dt><b>in=</b><i>infile</i> </dt>
<dd>If <i>infile</i> is specified, a nbody snapshot is
read in from this file (a quick way of preparing a simple system for testing
purposes is to use <i> <a href='snapenter.1.html'>snapenter(1NEMO)</i></a>
). The command line parameters are used
to determine the type and duration of the integration, and the modes of
output. Only one of the files <i>inputfile</i>, <i>restorefile</i>, <i>resumefile</i> may be
specified: if none are specified, a new Plummer model is generated (Default:
no file specification). </dd>

<dt><b>lastout=</b><i>lastoutfile</i> </dt>
<dd>If <i>lastoutfile</i> is specified,
then output data are written into this file in standard snapshot format
at the end of the integration. Since only one output is performed, the integration
can be viewed as a black box which maps an in-state to an out-state without
any clutter of intermediate information.  This option is useful for testing
purposes, since the <i>lastoutfile</i>s of two different runs can be compared
directly, for example using <a href='snapdiff.1.html'><i>snapdiff(1NEMO)</i></a>
; using snapdiff on two <i>outfile</i>s
would only compare the echos of the initial states, and later states would
have to be extracted using <a href='snaptrim.1.html'><i>snaptrim(1NEMO)</i></a>
 before passing them to <a href='snapdiff.1.html'><i>snapdiff(1NEMO)</i></a>

(Default: no file specification). </dd>

<dt><b>out=</b><i>outfile</i> </dt>
<dd>If <i>outfile</i> is specified, then
output data are written into this file in standard snapshot format, at
time intervals regulated by <i>dt_min_out</i> and <i>dt_maj_out</i> (see below; Default:
no file specification).  </dd>

<dt><b>save=</b><i>savefile</i> </dt>
<dd>If <i>savefile</i> is specified, the whole
system state is saved periodically at time intervals <i>dt_save</i>. (Default:
no file specification).  </dd>

<dt><b>restore=</b><i>restorefile</i> </dt>
<dd>If <i>restorefile</i> is specified,
a previously saved system state is read in from this file.  The command
line parameters are ignored (in contrast to the following option below),
and the system is run to completion solely according to the information
contained in <i>restorefile</i>. Thus, unless <i>restorefile</i> contains an interrupted
run, no integration will take place since <i>t_end</i> will already have been
reached. Only one of the files <i>inputfile</i>, <i>restorefile</i>, <i>resumefile</i> may be
specified: if none are specified, a new Plummer model is generated (Default:
no file specification).  </dd>

<dt><b>resume=</b><i>resumefile</i> </dt>
<dd>If <i>resumefile</i> is specified, a
previously saved system state is read in from this file.  The command line
parameters are used (in contrast to the previous option above) to determine
the type and duration of the integration, and the modes of output. Only
one of the files <i>inputfile</i>, <i>restorefile</i>, <i>resumefile</i> may be specified: if
none are specified, a new Plummer model is generated (Default: no file
specification). </dd>

<dt><b>restart=</b><i>restartfile</i> </dt>
<dd>If <i>restartfile</i> is specified, newton0
will deposit into this file a command which will continue the present run
after a systemcrash as if nothing had happened. Specifying a <i>restartfile</i>
will be ignored if no  <i>savefile</i> is specified as well. If both files are
given, then the system is supposed to execute the <i>restartfile</i> automatically
at reboot time (through some sort of specification in some sort of system
file), and all will be well again, one hopes (Default: no file specification).
</dd>

<dt><b>nbody=</b><i>integer</i> </dt>
<dd>number of particles in a newly generated Plummer model (Default:
<i>nbody</i>=3). </dd>

<dt><b>seed=</b><i>integer</i> </dt>
<dd>seed for the random number generator used in generating
a new Plummer model (default: a value 0, which will be converted into a
unique new value using UNIX&rsquo;s clock time, in seconds since once-upon-a-time-in-the-seventies-of-the-previous-century).
See also <a href='xrandom.1.html'><i>xrandom(1NEMO)</i></a>
 for more info on seed= </dd>

<dt><b>t_begin=</b><i>real</i> </dt>
<dd>time at which
the integration starts (Default: <b>t_begin=</b>0.0). </dd>

<dt><b>t_end=</b><i>real</i> </dt>
<dd>time at which the
integration will halt (Default: <b>t_end=</b>1.0). </dd>

<dt><b>dt_minor=</b><i>real</i> </dt>
<dd>time intervals
between minor outputs, when diagnostics are printed on the standard output
channel and diagnostics are added to <i>outfile</i> in snapshot format (Default:
<b>dt_minor=</b>0.5). </dd>

<dt><b>dt_major=</b><i>real</i> </dt>
<dd>time intervals between major outputs, when diagnostics
are printed on the standard output channel and diagnostics as well as a
complete set of particle data are added to <i>outfile</i> in snapshot format (Default:
<b>dt_major=</b>1.0). </dd>

<dt><b>dt_save=</b><i>real</i> </dt>
<dd>time intervals between saving a complete system
state (Default: <b>dt_save=</b>0.5).  </dd>

<dt><b>dt_max=</b><i>real</i> </dt>
<dd>maximum length of the allowed
integration time step which is shared between all particles (Default: <b>dt_max=</b>1000).
</dd>

<dt><b>nstep=</b><i>integer</i> </dt>
<dd>maximum number of integration steps, after which execution
of the program is halted immediately (Default: <b>nstep=</b>10000000). </dd>

<dt><b>min_pairdist=</b><i>real</i>
</dt>
<dd>minimum allowed (softened) pair distance. If any pair of particles anywhere
in the system attains a (softened) separation smaller than <i>min_pairdist</i>
integration is halted. Note: when using softening, the pair distance measured
is the softened distance between two particles. Specifying a minimum allowed
pair distance smaller than the effective softening length therefore cannot
halt integration (Default: <b>min_pairdist=</b>0.0). </dd>

<dt><b>de_max=</b><i>real</i> </dt>
<dd>maximum amount
of drift allowed in the total energy of the system. If the total energy
changes by more than this amount, integration is halted. The frequency with
which this test is applied is governed by the parameter <i>nstep_de</i> as described
below (Default: <b>de_max=</b>10000000).  </dd>

<dt><b>nstep_de=</b><i>integer</i> </dt>
<dd>indicates the number
of time steps after which the total energy value is checked against <i>de_macs</i>.
 (Default: <b>nstep_de=</b>10000000). </dd>

<dt><b>cpu_max=</b><i>real</i> </dt>
<dd>maximum amount of CPU time allowed
(expressed in minutes), after which execution of the program is halted
immediately (Default: <b>cpu_max=</b>10000000). </dd>

<dt><b>cpu_last_call=</b><i>real</i> </dt>
<dd>soft limit on
the amount of CPU time used (expressed in minutes): after this amount has
been exceeded, execution of the program will be halted at the time of the
next major output. This allows a more graceful exit than the above hard
option of <i>cpu_max</i>. Notice, however, that it may be prudent to give suitable
limits for both these parameters, since an extreme condition such as a
very close encounter may slow down simulated time to such an extent that
the time of the next scheduled major output may "never" be reached (Default:
<b>cpu_last_call=</b>10000000). </dd>

<dt><b>eta_acc=</b><i>real</i> </dt>
<dd>dimensionless integration accuracy
parameter,  used in determining the size of the integration time step:
the step length is taken as the small fraction <i>eta_acc</i> of the projected
collision time. The latter is defined as follows: the relative distance
and speed in each particle pair is determined, and from these the time
scale of change defined as the ratio of the relative speed and the relative
distance; the minimum of all these time scales is the projected collision
time (Default: <b>eta_acc=</b>0.01). </dd>

<dt><b>r0_soft=</b><i>real</i> </dt>
<dd>softening length used to soften
the potential of a point mass according to the type of softening specified
by <i>soft_focus</i> (see below; Default: <b>r0_soft=</b>0.0). </dd>

<dt><b>soft_focus=</b><i>softeningtype</i>
</dt>
<dd>type of softening used to soften the potential of a point mass. The following
options are implemented: <i>plummer</i> specifies the traditional softening in
which each point particle assumes the potential of a density distribution
according to a small Plummer model; <i>power4</i> is a generalization of the previous
one in which the square of the softening length is replaced by the fourth
power, giving a shorter range for the softening; <i>power8</i> is a similar generalization
to the eight power; <i>exponential</i> is again similar, but has an exponentially
short range; <i>sphere</i> replaces each point particle by a homogeneous sphere;
<i>shell</i> replaces each point particle by a homogeneous shell; <i>spline</i> replaces
each point particle by a cubic spline with compact support (Default: <b>soft_focus=</b>plummer).
</dd>

<dt><b>timestep=</b><i>timestepcriterion</i> </dt>
<dd>criterion for determinening the next timestep.
Currently only two criteria are provided: <i>constant</i> implies a constant time
step equal to the value of <i>eta_acc</i>; and <i>collision_time</i> which adaptively
determines the timestep as the fraction <i>eta_acc</i> of the timescale on which
the first pair configuration changes significantly. Expressed more accurately:
the relative distance and speed in each particle pair is determined, and
from these the time scale of change which would be the time scale for a
collision if position and velocity would be parallel and opposite; hence
the name (Default: <b>timestep=</b>constant). </dd>

<dt><b>diagnostics=</b><i>diagnosticstype</i> </dt>
<dd>choice
of diagnostics output, in binary as well as in ascii. This will be a place
where a large variety of types of diagnostics can be offered in future
versions. Presently only one type is implemented (Default: <b>diagnostics=</b>standard).
</dd>

<dt><b>scheme=</b><i>integrationscheme</i> </dt>
<dd>integration scheme used to integration Newton&rsquo;s
equations of motion for the whole system state (modeled as a set of 2*nbody*NDIM
simultaneous nonlinear ordinary differential equations). The following options
are implemented: <i>forward_euler</i>, <i>backward_euler</i>, <i>runge_kutta_2</i>, <i>runge_kutta_4</i>,
<i>runge_kutta_6</i>, <i>rk_fehlberg_45</i>. The first two are forward Euler and backwards
Euler schemes, respectively; the next three are Runge-Kutta schemes of 2nd,
4th and 6th order, respectively; and the last one is a Runge-kutta-Fehlberg
scheme of combined 4th and 5th order (the present implementation uses only
the final, 5th order Runge-Kutta information of this last scheme) (Default:
<b>scheme=</b>runge_kutta_4 for NEWTON0 and NEWTON0REG; <b>scheme=</b>leapfrog for NEWTON0TREE).
</dd>

<dt><b>headline=</b><i>string</i> </dt>
<dd>Optional headline, which is written as the first item in
the snapshot file, the next item being the snapshot itself (Default for
NEWTON0: "Newton0code: equal time steps"; for NEWTON0REG: "Newton0 code:
equal time steps &amp; regularization"; for NEWTON0TREE: "Newton0 code: equal
time steps &amp; hierarchical tree forces"). </dd>

<dt><b>tol=</b><i>real</i> </dt>
<dd>ONLY for NEWTON0TREE: the
tolerance parameter, which determines which cells are subdivided: for example,
in the simplest <i>celldivisonmethod</i> (see below), whenever the ratio of cell
size over cell distance to a body is smaller than <i>tol</i>, the interaction
between the cell and the body is computed directly without further subdivision
(Default: <b>tol=</b>1.0). </dd>

<dt><b>celldivision=</b><i>celldivisonmethod</i> </dt>
<dd>ONLY for NEWTON0TREE:
the method used to decide when to subdivide a cell from which one wants
to compute the gravitational attraction on an individual particle. The simplest
method, <i>constant_theta</i>, applies a constant opening-angle criterion (Default:
<b>celldivision=</b>constant_theta). </dd>

<dt><b>niter=</b><i>integer</i> </dt>
<dd>ONLY for NEWTON0REG: number
of iterations performed in trying to arrive at the correct time to end
the integration (since integration is with respect to pseudo-time, the end
of an integration time step can only be predicted roughly with respect
to real time; iterating with increasing smaller timestep helps to zoom
in on the correct end-time; Default: <b>niter=</b>3). </dd>
</dl>

<h2><a name='sect4' href='#toc4'>See Also</a></h2>
<a href='mkplummer.1.html'>mkplummer(1NEMO)</a>
,
<a href='nbody0.1.html'>nbody0(1NEMO)</a>
 <p>
STARLAB: <a href='http://www.sns.ias.edu/~starlab/'>http://www.sns.ias.edu/~starlab/</a>
 
<h2><a name='sect5' href='#toc5'>Caveats</a></h2>
<b>newton0</b> has
not been maintained for a long time, the code was  revived in 2001 as version
2.0, but for any serious research codes such as the <b>nbodyX</b> series written
by S.Aarseth (see e.g. <a href='nbody0.1.html'><i>nbody0(1NEMO)</i></a>
) or the <i>starlab</i> package should be used.

<h2><a name='sect6' href='#toc6'>Bugs</a></h2>
Running the code with a file named <i>savefile</i> lying around tricks poor
newton0 into assuming that it has just been restored to the land of the
living and that it should resume the task of its previous reincarnation
left undone according to the contents of <i>savefile</i>. Another bug: if intended
to be restored automatically this way, simply reissuing the original command
will revive the last saved system as advertised, but only after removing
(or better: renaming) the old <i>outfile</i>, since <i>newton0</i> is civilized enough
to refuse to overwrite the contents of the old <i>outfile</i>. One can then manually
concatenate the new and old <i>outfile</i> after completion of the run. <p>
The <i>Newton0
Primer</i> is lost... 
<h2><a name='sect7' href='#toc7'>Author</a></h2>
Piet Hut 
<h2><a name='sect8' href='#toc8'>Files</a></h2>
<br>
<pre>NEMO/src/nbody/evolve/newton0<tt> </tt>&nbsp;<tt> </tt>&nbsp;source code
</pre>
<h2><a name='sect9' href='#toc9'>Update History</a></h2>
<br>
<pre>25-May-87<tt> </tt>&nbsp;<tt> </tt>&nbsp;Version 1.0: created         <tt> </tt>&nbsp;<tt> </tt>&nbsp;PIET
5-feb-01<tt> </tt>&nbsp;<tt> </tt>&nbsp;V2.0: converted for NEMO V3<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
20-feb-04<tt> </tt>&nbsp;<tt> </tt>&nbsp;2.0a: integrated in NEMO V3, fixed an I/O problem<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT

