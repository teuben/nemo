<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>UNPROTO(1) manual page</title>
</head>
<body bgcolor='white'>
HTML automatically generated with <A HREF=http://manpages.ubuntu.com/manpages/bionic/man1/rman.1.html>rman</A><br>
<a href='#toc'>Table of Contents</a><p>
 </pre>
<h2><a name='sect0' href='#toc0'>Name</a></h2>
unproto - compile ANSI C with traditional UNIX C compiler 
<h2><a name='sect1' href='#toc1'>Package</a></h2>
 <br>
<pre>unproto
Synopsis 
/somewhere/cpp ...
cc cflags -E file.c | unproto &gt;file.i; cc cflags -c file.i
Description </pre>This document describes a filter that sits in between the UNIX
C preprocessor and the next UNIX C compiler stage, on the fly rewriting
ANSI-style syntax to old-style syntax. Typically, the program is invoked by
the native UNIX C compiler as an alternate preprocessor. The unprototyper
in turn invokes the native C preprocessor and massages its output. Similar
tricks can be used with the <a href='lint.1.html'>lint(1)</a>
 command. 
<p> Language constructs that are
always rewritten: 
<dl>

<dt>function headings, prototypes, pointer types </dt>
<dd>ANSI-C style
function headings, function prototypes, function pointer types and type
casts are rewritten to old style. &lt;stdarg.h&gt; support is provided for functions
with variable-length argument lists. </dd>

<dt>character and string constants </dt>
<dd>The \a
and \x escape sequences are rewritten to their (three-digit) octal equivalents.

<p> Multiple string tokens are concatenated; an arbitrary number of whitespace
or comment tokens may appear between successive string tokens. 
<p> Within string
constants, octal escape sequences are rewritten to the three-digit \ddd form,
so that string concatenation produces correct results. </dd>

<dt>date and time </dt>
<dd>The
__DATE__ and __TIME__ tokens are replaced by string constants of the form
"Mmm dd yyyy" and "hh:mm:ss", respectively. The result is subjected to string
concatenation, just like any other string constant. </dd>
</dl>
<p>
Language constructs
that are rewritten only if the program has been configured to do so: 
<dl>

<dt>void
types </dt>
<dd>The unprototyper can be configured to rewrite "void *" to "char *",
and even to rewrite plain "void" to "int". These features are configurable
because many traditional UNIX C compilers do not need them. 
<p> Note: (void)
argument lists are always replaced by empty ones. </dd>
</dl>
<p>
ANSI C constructs that
are not rewritten because the traditional UNIX C preprocessor provides
suitable workarounds: 
<dl>

<dt>const and volatile </dt>
<dd>Use the "-Dconst=" and/or "-Dvolatile="
preprocessor directives to get rid of unimplemented keywords. </dd>

<dt>token pasting
and stringizing </dt>
<dd>The traditional UNIX C preprocessor provides excellent
alternatives. For example: 
<p> <br>
<pre>#define string(bar)     "bar"           /* instead of: # x */
#define paste(x,y)      x/**/y         /* instead of: x##y */
</pre>
<p> There is a good reason why the # and ## operators are not implemented
in the unprototyper. After program text has gone through a non-ANSI C preprocessor,
all information about the grouping of the operands of # and ## is lost.
Thus, if the unprototyper were to perform these operations, it would produce
correct results only in the most trivial cases. Operands with embedded blanks,
operands that expand to null tokens, and nested use of # and/or ## would
cause all kinds of obscure problems. </dd>
</dl>
<p>
Unsupported ANSI features: 
<dl>

<dt>trigraphs
and #pragmas </dt>
<dd>Trigraphs are useful only for systems with broken character
sets. If the local compiler chokes on #pragma, insert a blank before the
"#" character, and enclose the offending directive between #ifdef and #endif.
</dd>
</dl>

<h2><a name='sect4' href='#toc4'>See Also</a></h2>
 <br>
<pre></pre><a href='cc.1.html'>cc(1)</a>
, how to specify a non-default C preprocessor. Some versions of the
<a href='lint.1.html'>lint(1)</a>
 command are implemented as a shell script. It should require only
minor modification for integration with the unprototyper. Other versions
of the <a href='lint.1.html'>lint(1)</a>
 command accept the same command syntax as the C compiler
for the specification of a non-default preprocessor. Some research may be
needed. 
<h2><a name='sect5' href='#toc5'>Files</a></h2>
 <br>
<pre>/wherever/stdarg.h, provided with the unproto filter.
Diagnostics </pre>Problems are reported on the standard error stream. A non-zero
exit status means that there was a problem. 
<h2><a name='sect7' href='#toc7'>Bugs</a></h2>
 </pre>The unprototyper should
be run on preprocessed source only: unexpanded macros may confuse the program.

<p> Declarations of (object) are misunderstood and will result in syntax errors:
the objects between parentheses disappear. 
<p> Sometimes does not preserve
whitespace after parentheses and commas. This is a purely aesthetical matter,
and the compiler should not care. Whitespace within string constants is,
of course, left intact. 
<p> Does not generate explicit type casts for function-argument
expressions.  The lack of explicit conversions between integral and/or pointer
argument types should not be a problem in environments where sizeof(int)
== <a href='sizeof.long.html'>sizeof(long)</a>
 == <a href='sizeof.pointer.html'>sizeof(pointer)</a>
.  A more serious problem is the lack
of automatic type conversions between integral and floating-point argument
types.  Let <a href='lint.1.html'>lint(1)</a>
 be your friend. 
<h2><a name='sect8' href='#toc8'>Author(s)</a></h2>
 <br>
<pre>Wietse Venema (wietse@wzv.win.tue.nl)
Eindhoven University of Technology
Department of Mathematics and Computer Science
Den Dolech 2, P.O. Box 513, 5600 MB Eindhoven, The Netherlands
Last Modification 
92/02/15 17:17:09
Version/Release 
1.5
