<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>SNAPBENCH(1NEMO) manual page</title>
</head>
<body bgcolor='white'>
This HTML automatically generated with <A HREF=http://manpages.ubuntu.com/manpages/bionic/man1/rman.1.html>rman</A> for <A HREF=https://astronemo.readthedocs.io>NEMO</A><br>
<a href='#toc'>Table of Contents</a><p>

<p> 
<h2><a name='sect0' href='#toc0'>Name</a></h2>
snapbench - benchmark (re)assigning masses to a snapshot 
<p> 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>snapbench</b>
[parameter=value] 
<p> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
<b>snapbench</b> performs a simple re-assigment of
the masses in a snapshot in a number of methods, in order to measure its
performance. <p>
It also uses two memory models of keeping a snapshot: an array
of structs (AOS) vs. a struct of arrays (SOA). snapshots&rsquo; are normally stored
on disk as SOA&rsquo;s, but most programs actually transpose them to an AOS, which
can be very in-efficient. <p>
A hidden code <i>snaprun</i> compares defining simple
variables (x,y,z) in a structure with an array pos[3], and also looping
over pos[] insted of hardcoding a simpler Eulerian type of update. Counter
intuitive, looping made the code about 4-8 times slower.  Simple variables
are slightly faster than using directly addressing the array.  Results vary
a bit on different processors. 
<p> 
<h2><a name='sect3' href='#toc3'>Parameters</a></h2>
 The following parameters are
recognized in order; they may be given in any order if the keyword is also
given. Use <b>--help</b> to confirm this man page is up to date.  
<dl>

<dt><b>in=</b> </dt>
<dd>Input (snapshot)
file. No default. [???]     </dd>

<dt><b>mass=</b> </dt>
<dd>Expression for new masses [1]    </dd>

<dt><b>iter=</b>
</dt>
<dd>Number of iterations to test. A large number is useful to downweight the
I/O contribution. [10]   </dd>

<dt><b>mode=</b> </dt>
<dd>reading input mode (1=body 2=arrays) [1]
  </dd>

<dt><b>out=</b> </dt>
<dd>output (snapshot) file, if needed []   
<p> </dd>
</dl>

<h2><a name='sect4' href='#toc4'>Examples</a></h2>

<p> Here is the standard
test that si part of NEMO&rsquo;s "make bench" 
<p>  
<p>   make -f $NEMO/src/nbody/trans/Benchfile
all<br>
 
<p>   mkplummer p6 1000000<br>
   snapbench p6 &rsquo;mass=1.0001&rsquo;   iter=1000 mode=0<br>
   snapbench p6 &rsquo;mass=1.0001*m&rsquo; iter=1000 mode=1<br>
   snapbench p6 &rsquo;mass=1.0001&rsquo;   iter=1000 mode=2<br>
   snapbench p6 &rsquo;mass=1.0001&rsquo;   iter=1000 mode=3<br>
 
<p>  with the following examples <br>
<pre>    CPU     modes: 0     1     2     3
  m2 (air)      0.36  2.89  2.81  0.37
  i9-12900K     0.20  4.42  3.30  0.23
  i7-1260P      0.30  6.39  5.89  0.37
  
</pre>
<p> 
<h2><a name='sect5' href='#toc5'>Caveats</a></h2>
Only reading and assignment is measured. No options for output (if
out= is given) 
<p> 
<h2><a name='sect6' href='#toc6'>See Also</a></h2>
snaprun, <a href='snapshot.5.html'>snapshot(5NEMO)</a>
 
<p> 
<h2><a name='sect7' href='#toc7'>Files</a></h2>
<br>
<pre>src/nbody/trans/snapbench.c
src/tutor/nbody/snaprun.c
</pre>
<h2><a name='sect8' href='#toc8'>Author</a></h2>
Peter Teuben 
<p> 
<h2><a name='sect9' href='#toc9'>History</a></h2>
<br>
<pre>12-mar-2024<tt> </tt>&nbsp;<tt> </tt>&nbsp;Finally documented<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
</pre><p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Parameters</a></li>
<li><a name='toc4' href='#sect4'>Examples</a></li>
<li><a name='toc5' href='#sect5'>Caveats</a></li>
<li><a name='toc6' href='#sect6'>See Also</a></li>
<li><a name='toc7' href='#sect7'>Files</a></li>
<li><a name='toc8' href='#sect8'>Author</a></li>
<li><a name='toc9' href='#sect9'>History</a></li>
</ul>
</body>
</html>
