<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>LOADOBJ(3NEMO) manual page</title>
</head>
<body bgcolor='white'>
HTML automatically generated with <A HREF=http://manpages.ubuntu.com/manpages/bionic/man1/rman.1.html>rman</A><br>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
loadobj, findfn, mysymbols - dynamic object file loader 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<br>
<pre>#include &lt;stdinc.h&gt;#include &lt;loadobj.h&gt;void loadobj(string pathname)proc findfn(string
fname)void mysymbols(string progname)
DescriptionThese routines provide
a uniform low-level I/O interface to loading object modules.  Higher level
I/O interfaces are present for a few standard operations (see e.g. potential(3NEMO)
and  bodytrans(3NEMO)). These routines are intended for applications where
a set of mathematical expressions is specified at runtime as function strings,
which are then evaluated for a large number of variable values. This is
done by compiling the set of function strings into byte code sequences,
which can be interpreted very efficiently for the various variable values.
 
The routine mysymbols is generally called once and in the beginning of
the program. It loads all symbols from the program pointed to by the argument
progname, which is normally the current  program. These symbols are then
stored in an internally defined symbol tree symtree. In case progname is
not the complete name, the PATH environment variable is used (see pathopen(3NEMO)).

The undefined symbols in each object module that is loaded with  loadobj
are resolved against the already existing symbol tree,  and new symbols
are added to the tree. If a symbol is not found to be resolved, this is
considered an error, and error(3NEMO) is called, which aborts the program.
In addition the code loaded into memory is properly relocated using information
in the object code. The argument pathname must be the proper filename, no
search path is provided for. 
After all symbols have been defined, the programmer
can obtain pointers to functions which is specified by name using findfn.

ExampleIn the following section of code gives an example of use. 
    proc fn;                   /* see defs in &lt;stdinc.h&gt; */
    mysymbols(getparam("argv0"));   /* get local symbols */
    loadobj("test.o");               /* load object code */
    fn = (proc) findfn("_test");       /* find function  */
    if (fn==NULL) error("No test");       /* catch error */
    (*fn)();         /* execute routine test() in test.o */
</pre>
<h2><a name='sect4' href='#toc4'>See Also</a></h2>
<a href='a.out.4.html'>a.out(4)</a>
, <a href='potential.3.html'>potential(3NEMO)</a>
, <a href='bodytrans.3.html'>bodytrans(3NEMO)</a>
), <a href='dlopen.3.html'>dlopen(3)</a>
, <a href='dyld.3.html'>dyld(3)</a>


<h2><a name='sect5' href='#toc5'>Author</a></h2>
Eric Roberts (original SunOS version), Peter Teuben (sun4, coff,
dl) 
<h2><a name='sect6' href='#toc6'>Files</a></h2>
<br>
<pre>~/src/kernel/loadobj         loadobj.c, loadobj*.c
</pre>Much like <a href='yapp.3.html'><i>yapp(3NEMO)</i></a>
, different implementations exist for different operating
systems. 
<h2><a name='sect7' href='#toc7'>Update History</a></h2>
<br>
<pre>23-jul-90       created         PJT
6-nov-91<tt> </tt>&nbsp;<tt> </tt>&nbsp;slight doc improvements; loadobjNEXT.c   <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
30-jun-03<tt> </tt>&nbsp;<tt> </tt>&nbsp;documented mach&rsquo;s dyld    <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
</pre> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Example</a></li>
<li><a name='toc4' href='#sect4'>See Also</a></li>
<li><a name='toc5' href='#sect5'>Author</a></li>
<li><a name='toc6' href='#sect6'>Files</a></li>
<li><a name='toc7' href='#sect7'>Update History</a></li>
</ul>
</body>
</html>
