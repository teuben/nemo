<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>DYNAMEM(3) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
dynamem, freeup - multidimensional dynamic array handling 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<br>
<b>char *dynamem(pointer,element_size,</b> <br>
<b>number_dimensions,dimensions ...)</b> <br>
<b>char **pointer;</b> 
<p> <br>
<a href='freeup.pointer.html'><b>freeup(pointer)</b></a>
 <br>
<b>char *pointer;</b> 
<p> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
<i>dynamem</i>  is the multidimensional analogue to
malloc(). It is passed a number of arguments: a pointer which on exiting
the procedure will point to the begining of the array, the element size,
the number of dimensions  required, followed by a list of the dimension
sizes.  To declare a 4 dimensional array normally one would code:  
<p> int
array[10][11][12][13]; 
<p>  however, this array is then fixed at compile time.
This same array can be declared dynamically at run time  using the following
code:  
<p> int ****array; 
<p> array = (int ****) dynamem(&amp;array, sizeof(int),
4, 10, 11, 12, 13); 
<p>  (Note that the number of levels of indirection in
the cast is equal to the number of dimensions in the array.) This enables
array sizes to be fixed via, for example,  command line arguments.  <p>
<i>freeup</i>
is the  <i>dynamem</i> analogue to free(). When passed an array previously  dynamically
declared by  <i>dynamem</i> the function returns this memory to the system. <p>
<i>dynamem</i>
attempts to set up the array required in the same way that  it would be
set up by the compiler at compile time. Thus a multidimensional dynamically
array declared using  <i>dynamem</i> can be used in exactly the same way as a
fixed array declared by the compiler. There is obviously some overhead in
the actual setting up of the array; however, this is minimal:  when dynamically
allocating 2 arrays of 346000 unsigned characters and one of the same number
of shorts all in two dimensions, the run time of a convolution of a 7x7
Lapacian- Marr filter over an image of size 720 by 480 varied as follows:
<p>
time convolve -fbfilt -X720 -Y480 -e &lt; bubble2 &gt; test.1 <br>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  222.0 real       213.4 user         1.6 sys  <br>
 <p>
time convolve -fbfilt -e &lt; bubble2 &gt; test.2 <br>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  225.2 real       212.5 user         2.7 sys  <br>
 <p>
which is probably adequate. From this we can see that  it takes 1.1 secs
for the fixed array to be set up and zeroed and only 0.9 secs for the array
to be dynamically declared using <i>dynamem</i>;<i></i> however, using dynamem the array
is not initialized to 0 and this is the reason for the 0.2 speed increase.

<h2><a name='sect3' href='#toc3'>Files</a></h2>
/users/alv/everson/usr/lib/dynamem.a 
<h2><a name='sect4' href='#toc4'>See Also</a></h2>
<a href='malloc.3.html'>malloc(3)</a>
, <a href='convolve.1.html'>convolve(1)</a>


<h2><a name='sect5' href='#toc5'>Diagnostics</a></h2>
<br>
<i>dynamem</i> returns NULL if it is unable to allocate sufficient memory for
the array. <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Files</a></li>
<li><a name='toc4' href='#sect4'>See Also</a></li>
<li><a name='toc5' href='#sect5'>Diagnostics</a></li>
</ul>
</body>
</html>
