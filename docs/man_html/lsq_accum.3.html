<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>LSQ(3NEMO) manual page</title>
</head>
<body bgcolor='white'>
HTML automatically generated with <A HREF=http://manpages.ubuntu.com/manpages/bionic/man1/rman.1.html>rman</A><br>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
lsq_zero, lsq_accum, lsq_solve - least squares fitting utilities 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<br>
<pre>int lsq_zero (n, mat, vec)
int lsq_accum (n, mat, vec, a, w)
int lsq_solve (n, mat, vec, sol)
int lsq_cfill (n, mat, c, sol)
int n, c;
real mat[n*n], vec[n], sol[n], a[n+1], w;

DescriptionThese routines provide a low level interface to solving linear
least squares problems using  the Normal Equations (see e.g. Numerical Recepies,
Press et al.). These routines have the advantage that they don&rsquo;t need the
extra temporary arrays containing the data, i.e. the Design Matrix, and directly
accumulate the data in the appropriate spots in the symmetric Normal Matrix.
lsq_accum accumulates the data into the normal equations matrix that is
 inverted in lsq_solve. Before the data is accumulated, the matrix  and
right hand side vector need to be reset using lsq_zero. During accumulation,
a weight, w, can be given to each datapoint (Note: this is a linear weight,
by which the data is multiplied. If you&rsquo;re used to enter the dispersion,
you should enter 1/sigma^2). On output the matrix mat contains the inverse
of the normal matrix, and hence its diagonal elements the square of the
errors of the fitted parameters. The fitted parameters themselves are returned
in the array sol. 
ExampleIn this example a large 2D image matrix is fitted
with an intensity gradient of the form I(x,y)=a+bx+cy: 
    double mat[3*3],vec[3],a[4],
    real data[nx*ny];
    lsq_zero(3,mat,vec);
    for (ix=0; ix&lt;nx; ix++)
    for (iy=0; iy&lt;ny; iy++) {
        a[0] = 1.0
        a[1] = ix;
        a[2] = iy;
        a[3] = data[ix*ny+iy];
        lsq_accum(3,mat,vec,a,1.0);
    }
    lsq_solve(3,mat,vec,a);
    printf("a+bx+cy:  a=%f b=%f c=%f\n", a[0],a[1],a[2]);
</pre>
<h2><a name='sect4' href='#toc4'>See Also</a></h2>
<a href='lsqfit.3.html'>lsqfit(3NEMO)</a>
, <a href='matinv.3.html'>matinv(3NEMO)</a>
, <a href='mpfit.3.html'>mpfit(3NEMO)</a>
 
<h2><a name='sect5' href='#toc5'>Author</a></h2>
Peter Teuben 
<h2><a name='sect6' href='#toc6'>Files</a></h2>
<br>
<pre>~/src/kernel/misc  <tt> </tt>&nbsp;<tt> </tt>&nbsp;lsq.c
</pre>
<h2><a name='sect7' href='#toc7'>Update History</a></h2>
<br>
<pre>29-sep-90<tt> </tt>&nbsp;<tt> </tt>&nbsp;created  <tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
19-feb-92<tt> </tt>&nbsp;<tt> </tt>&nbsp;updated doc, and properly redfined the weights<tt> </tt>&nbsp;<tt> </tt>&nbsp;PJT
</pre> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Example</a></li>
<li><a name='toc4' href='#sect4'>See Also</a></li>
<li><a name='toc5' href='#sect5'>Author</a></li>
<li><a name='toc6' href='#sect6'>Files</a></li>
<li><a name='toc7' href='#sect7'>Update History</a></li>
</ul>
</body>
</html>
