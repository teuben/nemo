<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>VOGL(3) manual page</title>
</head>
<body bgcolor='white'>
HTML automatically generated with <A HREF=http://manpages.ubuntu.com/manpages/bionic/man1/rman.1.html>rman</A><br>
<a href='#toc'>Table of Contents</a><p>
 
<h2><a name='sect0' href='#toc0'>Name</a></h2>
VOGL - A very ordinary GL Library. 
<p> 
<h2><a name='sect1' href='#toc1'>Description</a></h2>
<p>
<i>VOGL</i> is a library of
C routines which try to allow a programmer to write programs which can
be moved to machines which have the Silicon Graphics GL library on them.
It is based entirely on the VOGLE graphics library, and as a result can
handle circles, curves, arcs, patches, and polygons in a device independent
fashion. Simple hidden line removal is also available via polygon backfacing.
Access to hardware text and double buffering of drawings depends on the
driver.  There is also a FORTRAN interface but as it goes through the C
routines FORTRAN users are warned that arrays are in row-column order in
C. Both the long FORTRAN names and the shortened six character names are
supported. People interested in using software text should see the hershey
library,  <a href='HERSHEY.3.html'><i>HERSHEY(3)</a>
.</i> 
<p> Some routines are only available in VOGL. If you include
them in programs it is advisable to put #ifdef VOGL ... #endif around them.
The constant VOGL is defined whenever a VOGL header file is included. 
<p> It
should be noted that there are a number of routines that take the type
<i>Angle</i> for some of their parameters. All angles specified this way are actually
<i>Integer</i> Tenths Of Degrees. (Don&rsquo;t ask!) 
<p> 
<h3><a name='sect2' href='#toc2'>Include files.</a></h3>
<p>
There are two include
files provided with vogl: vogl.h and vodevice.h. The file vogl.h has the type
definitions and function interfaces, ideally it is included where you would
include gl.h on an SGI. The file vodevice.h has the devices in it, and it
is included where you would include device.h on an SGI. The following is
a brief summary of the VOGL subroutines. 
<h3><a name='sect3' href='#toc3'>Using X toolkits ans Sunview</a></h3>
<p>
For
X11 and Sunview based applications, it is posible for VOGL to use a window
that is supplied by that application&rsquo;s toolkit. Under these circumstances,
the toolkit is is responsible for handling of all input events, and VOGL
simply draws into the supplied  window. These calls are only available from
C. Also see the directories examples/xt, examples/xview and examples/sunview.

<p> For X based toolkits the following two calls may be used: 
<dl>

<dt><i>vo_xt_window(display,</i>
xwin, width, height) </dt>
<dd>Tells VOGL to use the supplied window  <i>xwin</i> <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;vo_xt_window(display, xwin, width, height)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Display<tt> </tt>&nbsp;<tt> </tt>&nbsp;*display;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Window<tt> </tt>&nbsp;<tt> </tt>&nbsp;xwin;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;int<tt> </tt>&nbsp;<tt> </tt>&nbsp;width, height;
</pre>This routine should be called before calling "ginit()". </dd>

<dt><i>vo_xt_win_size(width,</i>
height) </dt>
<dd>Tells VOGL that the supplied window has changed size. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;vo_xt_win_size(width, height)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;int<tt> </tt>&nbsp;<tt> </tt>&nbsp;width, height;
</pre>
<p></dd>

<dt> For sunview based applications the following two calls may be used: </dt>
<dd></dd>

<dt><i>vo_sunview_canvas(canvas,</i>
width, height) </dt>
<dd>Tells VOGL to use the supplied sunview canvas  <i>canvas</i> <br>
<pre>


</pre>
<p></dd>

<dt><tt> </tt>&nbsp;<tt> </tt>&nbsp;vo_sunview_canvas(canvas, width, height)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Canvas<tt> </tt>&nbsp;<tt> </tt>&nbsp;canvas;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;int<tt> </tt>&nbsp;<tt> </tt>&nbsp;width, height;
</dt>
<dd>This routine should be called before calling "ginit()". 
<p> </dd>

<dt><i>vo_sunview_canvas_size(width,</i>
height) </dt>
<dd>Tells VOGL that the supplied canvas has changed size. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;vo_sunview_canvas_size(width, height)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;int<tt> </tt>&nbsp;<tt> </tt>&nbsp;width, height;
</pre>
<p> </dd>
</dl>

<h3><a name='sect4' href='#toc4'>Device routines.</a></h3>

<dl>

<dt><i>vinit(device)</i> </dt>
<dd>Tell VOGL what the device is. This routine
needs to be called if the environment variable VDEVICE isn&rsquo;t set, or if
the value in VDEVICE is not to be used. <br>
<pre>                
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine vinit(device, len)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;character *(*) device
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer len
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;vinit(device);
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;char     *device;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Note 1 :- Current available devices are:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    tek - tektronix 4010 and compatibles
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    hpgl - HP Graphics language and compatibles
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    dxy - roland DXY plotter language
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    postscript - postscript devices
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    ppostscript - postscript devices (portrait mode)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    sun - Sun workstations running sunview
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    X11 - X windows (SUN&rsquo;s Openwindows etc etc)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    decX11 - the decstation (old) window manager
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;     This is only included in case you need it.
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    apollo - Apollo workstations
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    NeXT   - NeXTStep
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    hercules - IBM PC hercules graphics card
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    cga - IBM PC cga graphics card
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    ega - IBM PC ega graphics card
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    vga - IBM PC vga graphics card
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    sigma - IBM PC sigma graphics card.
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    Sun, X11, decX11, apollo, hercules, cga
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    and ega support double buffering.
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Note 2 :- If device is a NULL or a null string the value
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;of the environment variable "VDEVICE" is taken as the
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;device type to be opened.
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Note 3 :- after init it is wise to explicitly
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;clear the screen.
<tt> </tt>&nbsp;<tt> </tt>&nbsp;e.g.: in C
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;color(BLACK);
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;clear();
<tt> </tt>&nbsp;<tt> </tt>&nbsp;or    in Fortran
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;call color(BLACK)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;call clear
</pre></dd>

<dt><i>ginit()</i> </dt>
<dd>Open the graphics device and do the basic initialisation. This routine
is marked for obsolescence. The routine <i>winopen</i> (see below) should be used
instead. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine ginit
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;ginit()
</pre></dd>

<dt><i>winopen(title)</i> </dt>
<dd>Open the graphics device and do the basic initialisation.
This routine should be used instead of <i>ginit.</i> <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine winopen(title, len)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;character*(*) title
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer len
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;winopen(title)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;char<tt> </tt>&nbsp;<tt> </tt>&nbsp;*title;
</pre></dd>

<dt><i>gexit()</i> </dt>
<dd>Reset the window/terminal (must be the last VOGL routine called)
<br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine gexit
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;gexit()
</pre></dd>

<dt><a href='voutput.path.html'><a href='voutput.path.html'><i>voutput(path)</i></a>
</a>
 </dt>
<dd>Redirect output from *next* ginit to file given by path. This
routine only applies to devices drivers that write to stdout e.g. postscript
and hpgl. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine voutput(path, len)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;character*(*) path
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer len
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;voutput(path)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;char<tt> </tt>&nbsp;<tt> </tt>&nbsp;*path;
</pre></dd>

<dt><i>vnewdev(device)</i> </dt>
<dd>Reinitialize VOGL to use a new device without changing
attributes, viewport etc. (eg. window and viewport specifications) <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine vnewdev(device, len)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;character *(*) device
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer len
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;vnewdev(device)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;char *device;
</pre><i>getplanes()</i> Returns the number of bit planes (or color planes) for a particular
device. The number of colors displayable by the device is then 2**(nplanes-1)
<br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer function  getplanes()
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;getplanes()
</pre></dd>
</dl>

<h3><a name='sect5' href='#toc5'>Routines for controling flushing or syncronisation of the display.</a></h3>
On some
devices (particularly X11) considerable speedups in display can be achieved
by not flushing each graphics primitive call to the actual display until
necessary. VOGL automatically delays flushing under in following cases:
<br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;- Within a callobj() call.
<tt> </tt>&nbsp;<tt> </tt>&nbsp;- Within curves and patches.
<tt> </tt>&nbsp;<tt> </tt>&nbsp;- Within bgn*/end* calls.
<tt> </tt>&nbsp;<tt> </tt>&nbsp;- When double buffering (the flush is only done withing swapbuffers).
</pre>There are two user routines (which are NOT GL compatible) that can be used
to control flushing. 
<dl>

<dt><i>vsetflush(yesno)</i> </dt>
<dd>Set global flushing status. If yesno
= 0 (.false.) then don&rsquo;t do any flushing (except in swapbuffers(), or vflush()).
If yesno = 1 (.true.)  then do the flushing as described above. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine vsetflush(yesno)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;logical yesno
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;void
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;vsetflush(yesno)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;int<tt> </tt>&nbsp;<tt> </tt>&nbsp;yesno;
</pre></dd>

<dt><i>vflush()</i> </dt>
<dd>Call the device flush or syncronisation routine. This forces a
flush. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine vflush
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;void
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;vflush();
</pre></dd>
</dl>

<h3><a name='sect6' href='#toc6'>Routines For Setting Up Windows.</a></h3>
Some devices are basically window orientated
- like sunview and X11. You can give VOGL some information about the window
that it will use with these routines. These can make your code very device
dependent. Both routines take  arguments which are in device space. (0, 0)
is the bottom left hand corner in device space. To have any effect these
routines must be called before ginit or winopen. For the X11 device, an
entry may be made in your .Xdefaults file of the form vogl.Geometry =150x500+550+50
(where you specify your geometry as you please). 
<dl>

<dt><i>prefposition(x1,</i> y1, x2,
y2) </dt>
<dd>Specify the preferred position of the window opened by the *next* winopen.
<br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine prefposition(x1, y1, x2, y2)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer x1, y1, x2, y2
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;prefposition(x1, y1, x2, y2)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long<tt> </tt>&nbsp;<tt> </tt>&nbsp;x1, y1, x2, y2
</pre></dd>

<dt><i>prefsize(width,</i> height) </dt>
<dd>Specify the preferred width and height of the window
opened by the *next* winopen. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine prefsize(width, height)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer width, height
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;prefsize(width, height)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long<tt> </tt>&nbsp;<tt> </tt>&nbsp;width, height;
</pre></dd>

<dt><i>reshapeviewport</i> </dt>
<dd>This is occasionally used in Iris GL if a REDRAW event
rolls up. While VOGL is unlikely to ever provide a REDRAW event the call
is provided for compatibility. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine reshap
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;reshapeviewport()
</pre></dd>
</dl>

<h3><a name='sect7' href='#toc7'>General Routines.</a></h3>

<dl>

<dt><i>clear()</i> </dt>
<dd>Clears the current viewport to the current colour.
<br>
<pre>                
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine clear
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;clear()
</pre></dd>

<dt><i>color(col)</i> </dt>
<dd>Set the current colour. The standard colours are as follows:
<br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;black = 0       red = 1         green = 2       yellow = 3
<tt> </tt>&nbsp;<tt> </tt>&nbsp;blue = 4        magenta = 5     cyan = 6        white = 7.
<tt> </tt>&nbsp;<tt> </tt>&nbsp;These are included in vogl.h as:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;   BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN and WHITE.
<tt> </tt>&nbsp;<tt> </tt>&nbsp;When using fortran these are included in fvogl.h as
<tt> </tt>&nbsp;<tt> </tt>&nbsp;   BLACK, RED, GREEN, YELLOW, BLUE, MAGENT, CYAN and WHITE.
</pre><br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine color(col)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer col
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;color(col)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Colorindex<tt> </tt>&nbsp;<tt> </tt>&nbsp;col;
</pre></dd>

<dt><i>colorf(col)</i> </dt>
<dd>Same as  <i>color</i> only it takes a floating point argument. In Iris
GL there are sometimes good reasons for using this routine over <i>color.</i> See
the GL manual for more details. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine colorf(col)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real col
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;colorf(col)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;float<tt> </tt>&nbsp;<tt> </tt>&nbsp;col;
</pre></dd>

<dt><i>mapcolor(indx,</i> red, green, blue) </dt>
<dd>Set the color map index indx to the color
represented by (red, green, blue). If the device has no color map this call
does nothing. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine mapcolor(indx, red, green, blue)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer indx, red, green, blue
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;mapcolor(indx, red, green, blue)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Colorindex<tt> </tt>&nbsp;<tt> </tt>&nbsp;indx;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;short<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;red, green, blue;
</pre></dd>

<dt><i>defbasis(id,</i> mat) </dt>
<dd>Define basis number id to be the matrix mat. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine defbasis(id, mat)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer id
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real mat(4, 4)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;defbasis(id, mat)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;short<tt> </tt>&nbsp;<tt> </tt>&nbsp;id;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Matrix<tt> </tt>&nbsp;<tt> </tt>&nbsp;mat;
</pre></dd>

<dt><i>polymode(mode)</i> </dt>
<dd><i>NOTE:-</i> For this call to <i>have</i> any effect it must have been
<i>conditionally</i> compilied into the library. (See polygons.c for details) Control
the filling of polygons. It expects one of the following PYM_LINE, which
means only the edges of the polygon will be drawn and PYM_FILL which means
fill the polygon (the default). PYM_POINT and PYM_HOLLOW are also recognised
but they don&rsquo;t behave quite as they would with SGI GL. 
<p> Also note that in
Fortran the corresponding constants are truncated to PYM_LI, PYM_FI, PYM_PO
and PYM_HO respectivly. These appear in fvogl.h. 
<p> <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine polymode(mode)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer mode
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;polymode(mode)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long<tt> </tt>&nbsp;<tt> </tt>&nbsp;mode;
</pre></dd>
</dl>

<h3><a name='sect8' href='#toc8'>The Device Queue and Valuator Routines.</a></h3>
The available devices are defined
in the header files vodevice.h and for FORTRAN fvodevice.h 
<dl>

<dt><i>qdevice(dev)</i> </dt>
<dd>Enable
a device. Note: in VOGL the queue is of length 1. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine qdevice(dev)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer dev
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;qdevice(dev)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Device<tt> </tt>&nbsp;<tt> </tt>&nbsp;dev;
</pre></dd>

<dt><i>unqdevice(dev)</i> </dt>
<dd>Disable a device.  <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine qdevice(dev)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer dev
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;qdevice(dev)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Device<tt> </tt>&nbsp;<tt> </tt>&nbsp;dev;
</pre></dd>

<dt><i>qread(data)</i> </dt>
<dd>Read an event from the device queue. This routines blocks until
something happens. Note: it is important to have called qdevice before doing
this. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer function qread(data)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer*2 data
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long qread(data)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;short<tt> </tt>&nbsp;<tt> </tt>&nbsp;*data;
</pre></dd>

<dt><i>isqueued(dev)</i> </dt>
<dd>Check to see if device dev is enabled for queueing. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;logical function isqueued(dev)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer dev
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Boolean isqueued(dev)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;short<tt> </tt>&nbsp;<tt> </tt>&nbsp;*dev;
</pre></dd>

<dt><i>qtest()</i> </dt>
<dd>Check if there is anything in the queue. Note: in VOGL the queue
is only 1 entry deep. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;logical function qtest
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Boolean qtest()
</pre></dd>

<dt><i>qreset()</i> </dt>
<dd>Reset the device queue. This will get rid of any pending events.
<br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine qreset
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;qreset()
</pre></dd>

<dt><i>getbutton(dev)</i> </dt>
<dd>Returns the up (0) or <a href='down.1.html'>down (1)</a>
 state of a button. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;logical function getbutton(dev)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer dev
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Boolean getbutton(dev)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Device<tt> </tt>&nbsp;<tt> </tt>&nbsp;dev;
</pre></dd>

<dt><i>getvaluator(dev)</i> </dt>
<dd>Return the current value of the valuator. Currently the
only valuators supported are MOUSEX and MOUSEY. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer function getvaluator(dev)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer dev
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long getvaluator(dev)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Device<tt> </tt>&nbsp;<tt> </tt>&nbsp;dev;
</pre></dd>
</dl>

<h3><a name='sect9' href='#toc9'>Viewport Routines.</a></h3>

<dl>

<dt><i>viewport(left,</i> right, bottom, top) </dt>
<dd>Specify which part
of the screen to draw in. Left, right, bottom, and top are integer values
in screen coordinates. <br>
<pre>                
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine viewport(left, right, bottom, top)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer left, right, bottom, top
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;viewport(left, right, bottom, top)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Screencoord      left, right, bottom, top;
</pre></dd>

<dt><i>pushviewport()</i> </dt>
<dd>Save current viewport on the viewport stack. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine pushviewport
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;pushviewport()
</pre></dd>

<dt><i>popviewport()</i> </dt>
<dd>Retrieve last pushed viewport. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine popviewport
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;popviewport()
</pre></dd>

<dt><i>getviewport(left,</i> right, bottom, top) </dt>
<dd>Returns the left, right, bottom and
top limits of the current viewport in screen coordinates. <br>
<pre>                
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine getviewport(left, right, bottom, top)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer*2 left, right, bottom, top
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;getviewport(left, right, bottom, top)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Screencoord      *left, *right, *bottom, *top;
</pre></dd>
</dl>

<h3><a name='sect10' href='#toc10'>Attribute Stack Routines.</a></h3>
<p>
The attribute stack contains details such as current
color, current line style  and width, and the current font number. If you
need to prevent object calls form changing these, use <i>pushattributes</i> before
the call and <i>popattributes</i> after. 
<dl>

<dt><i>pushattributes()</i> </dt>
<dd>Save the current attributes
on the attribute stack. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine pushattributes
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;pushattributes()
</pre></dd>

<dt><i>popattributes()</i> </dt>
<dd>Restore the attributes to what they were at the last <i>pushattribute().</i>
<br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine popattributes
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;popattributes()
</pre></dd>
</dl>

<h3><a name='sect11' href='#toc11'>Projection Routines.</a></h3>
<p>
All the projection routines define a new transformation
matrix, and  consequently the world units. Parallel projections are defined
by ortho or ortho2. Perspective projections can be defined by perspective
and window. Note the types Angle, etc, are defined in vogl.h. Remember angles
are in tenths of degrees. 
<dl>

<dt><i>ortho(left,</i> right, bottom, top, near, far) </dt>
<dd>Define
x (left, right), y (bottom, top), and z (near, far) clipping planes. The
near and far clipping planes are actually specified as distances along
the line of sight. These distances can also be negative. The actual location
of the clipping planes is z = -near_d and z = -far_d. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine ortho(left, right, bottom, top, near_d, far_d)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real left, right, bottom, top, near_d, far_d
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;ortho(left, right, bottom, top, near_d, far_d)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord <tt> </tt>&nbsp;<tt> </tt>&nbsp;left, right, bottom, top, near_d, far_d;
</pre></dd>

<dt><i>ortho2(left,</i> right, bottom, top) </dt>
<dd>Define x (left, right), and y (bottom,
top) clipping planes. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine ortho2(left, right, bottom, top)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real left, right, bottom, top
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;ortho2(left, right, bottom, top)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;float<tt> </tt>&nbsp;<tt> </tt>&nbsp;left, right, bottom, top;
</pre></dd>

<dt><i>perspective(fov,</i> aspect, near, far) </dt>
<dd>Specify a perspective viewing pyramid
in world coordinates by giving a field of view, aspect ratio and the distance
from the eye of the near and far clipping plane. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine perspective(fov, aspect, near, far)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer fov
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real aspect, near, far
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;perspective(fov, aspect, near, far)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Angle <tt> </tt>&nbsp;<tt> </tt>&nbsp;fov;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;float<tt> </tt>&nbsp;<tt> </tt>&nbsp;aspect;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;near, far;












</pre></dd>
</dl>

<h3><a name='sect12' href='#toc12'><i>window(left,</i> right, bot, top, near, far)Specify a perspective viewing pyramid
in world coordinates bygiving the rectangle closest to the eye (ie. at the
near clippingplane) and the distances to the near and far clipping planes.
               <tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine window(left, right, bot, top, near, far)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real
left, right, bot, top, near, far<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    <tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;window(left, right, bot, top, near,
far)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;float     left, right, bot, top, near, far;Matrix Stack Routines.</a></h3>

<dl>

<dt><i>pushmatrix()</i>
</dt>
<dd>Save the current transformation matrix on the matrix stack. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine pushmatrix
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;pushmatrix()
</pre></dd>

<dt><i>popmatrix()</i> </dt>
<dd>Retrieve the last matrix pushed and make it the current transformation
matrix. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine popmatrix
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;popmatrix()
</pre></dd>
</dl>

<h3><a name='sect13' href='#toc13'>Viewpoint Routines.</a></h3>
<p>
Viewpoint routines alter the current tranformation matrix.

<dl>

<dt><i>polarview(dist,</i> azim, inc, twist) </dt>
<dd>Specify the viewer&rsquo;s position in polar
coordinates by giving the distance from the viewpoint to the world origin,
the azimuthal angle in the x-y plane, measured from the y-axis, the incidence
angle in the y-z plane, measured from the z-axis, and the twist angle about
the line of sight. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine polarview(dist, azim, inc, twist)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real dist
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer azim, inc, twist
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;polarview(dist, azim, inc, twist)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;dist;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Angle<tt> </tt>&nbsp;<tt> </tt>&nbsp;azim, inc, twist;
</pre></dd>

<dt><i></i> lookat(vx, vy, vz, px, py, pz, twist) </dt>
<dd>Specify the viewer&rsquo;s position by
giving a viewpoint and a reference point in world coordinates. A twist about
the line of sight may also be given. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine lookat(vx, vy, vz, px, py, pz, twist)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real vx, vy, vz, px, py, pz
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer twist
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;lookat(vx, vy, vz, px, py, pz, twist)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;float<tt> </tt>&nbsp;<tt> </tt>&nbsp;vx, vy, vz, px, py, pz;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Angle<tt> </tt>&nbsp;<tt> </tt>&nbsp;twist;
</pre></dd>
</dl>

<h3><a name='sect14' href='#toc14'>Move Routines.</a></h3>
<p>
There are variations on all these routines that end in &rsquo;s&rsquo; and
also end in &rsquo;i&rsquo;. In the case of the &rsquo;s&rsquo; variations they take arguments of type
Scoord in C and integer*2 in FORTRAN. In the case of the &rsquo;i&rsquo; variations they
take arguments of type Icoord in C and integer in FORTRAN. 
<dl>

<dt><i>move(x,</i> y, z)
</dt>
<dd>Move current graphics position to (x, y, z). (x, y, z) is a point in world
coordinates. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine move(x, y, z)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x, y, z
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;move(x, y, z)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y, z;
</pre></dd>

<dt><i>rmv(deltax,</i> deltay, deltaz) </dt>
<dd>Relative move. deltax, deltay, and deltaz are
offsets in world units. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine rmv(deltax, deltay, deltaz)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real deltax, deltay, deltaz
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;rmv(deltax, deltay, deltaz)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord   deltax, deltay, deltaz;
</pre></dd>

<dt><i>move2(x,</i> y) </dt>
<dd>Move graphics position to point (x, y). (x, y) is a point in
world coordinates. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine move2(x, y)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x, y
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;move2(x, y)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y;
</pre></dd>

<dt><i>rmv2(deltax,</i> deltay) </dt>
<dd>Relative move2. deltax and deltay are offsets in world
units. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine rmv2(deltax, deltay)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real deltax, deltay
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;rmv2(deltax, deltay)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;deltax, deltay;
</pre>
<p> </dd>
</dl>

<h3><a name='sect15' href='#toc15'>Line routines.</a></h3>
<p>
These  routines set the line style and line width if the
current device is capable of doing so.  
<dl>

<dt><i>deflinestyle(n,</i> style) </dt>
<dd>Define a
line style and binds it to the integer n. The  line style is a bit pattern
of 16 bits width. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine deflin(n, style)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer<tt> </tt>&nbsp;<tt> </tt>&nbsp;n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer style
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;deflinestyle(n, style)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;short<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Linestyle<tt> </tt>&nbsp;<tt> </tt>&nbsp;style;
</pre>
<p> </dd>

<dt><a href='setlinestyle.n.html'><a href='setlinestyle.n.html'><i>setlinestyle(n)</i></a>
</a>
 </dt>
<dd>Sets the current line style. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine setlin(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer<tt> </tt>&nbsp;<tt> </tt>&nbsp;n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;setlinestyle(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;short<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
</pre>
<p> </dd>

<dt><a href='linewidth.n.html'><a href='linewidth.n.html'><i>linewidth(n)</i></a>
</a>
 </dt>
<dd>Sets the current line width to &rsquo;n&rsquo; pixels wide. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine linewi(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer<tt> </tt>&nbsp;<tt> </tt>&nbsp;n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;linewidth(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;short<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
</pre>
<p> <tt> </tt>&nbsp;<tt> </tt>&nbsp;<br>
 </dd>
</dl>

<h3><a name='sect16' href='#toc16'>Drawing Routines.</a></h3>
<p>
There are variations on all these routines that end in
&rsquo;s&rsquo; and also end in &rsquo;i&rsquo;. In the case of the &rsquo;s&rsquo; variations they take arguments
of type Scoord in C and integer*2 in FORTRAN. In the case of the &rsquo;i&rsquo; variations
they take arguments of type Icoord in C and integer in FORTRAN. 
<dl>

<dt><i>draw(x,</i>
y, z) </dt>
<dd>Draw from current graphics position to (x, y, z). (x, y, z) is a point
in world coordinates. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine draw(x, y, z)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x, y, z
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;draw(x, y, z)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y, z;
</pre></dd>

<dt><i>rdr(deltax,</i> deltay, deltaz) </dt>
<dd>Relative draw. deltax, deltay, and deltaz are
offsets in world units. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine rdr(deltax, deltay, deltaz)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real deltax, deltay, deltaz
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;rdr(deltax, deltay, deltaz)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord   deltax, deltay, deltaz;
</pre></dd>

<dt><i>draw2(x,</i> y) </dt>
<dd>Draw from current graphics position to point (x, y). (x, y)
is a point in world coordinates. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine draw2(x, y)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x, y
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;draw2(x, y)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y;
</pre></dd>

<dt><i>rdr2(deltax,</i> deltay) </dt>
<dd>Relative draw2. deltax and deltay are offsets in world
units. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine rdr2(deltax, deltay)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real deltax, deltay
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;rdr2(deltax, deltay)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord   deltax, deltay;
</pre></dd>
</dl>

<h3><a name='sect17' href='#toc17'>Vertex calls.</a></h3>
<p>
There are calls which we term &rsquo;vertex calls&rsquo; which simply specify
a point in 4D, 3D or 2D. These calls take an array which specifies the coordinates
of the point. The interpretation of these points is described below. 
<p> <i>v4d(v)</i>
Specify a <a href='vertex.point.html'>vertex(point)</a>
 in 4D using double precision numbers. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine v4d(v)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real *8 v(4)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;v4d(v)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;double v[4];
</pre><i>v4f(v)</i> Specify a <a href='vertex.point.html'>vertex(point)</a>
 in 4D using single precision floating point
numbers. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine v4f(v)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real v(4)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;v4f(v)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;float v[4];
</pre><i>v4i(v)</i> Specify a <a href='vertex.point.html'>vertex(point)</a>
 in 4D using integer numbers <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine v4i(v)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer v(4)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;v4i(v)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long v[4];
</pre><i>v4s(v)</i> Specify a <a href='vertex.point.html'>vertex(point)</a>
 in 4D using short integer numbers <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine v4s(v)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer *2  v(4)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;v4s(v)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;short v[4];
</pre>
<p> <p>
There are also equivalent calls for 3D points (v3d, v3f, v3i, v3s)  and
2D points (v2d, v2f, v2i, v2s). The only difference is the number of elements
that each vertex needs to be specified. It should also be noted the the
different data types (ie. double, float, long and short) are merely different
ways of representing the same basic coordinate data (calling v3s with v[]
= {100,200,200} is the same as calling v3f with v[] = {100.0, 200.0, 200.0}).

<p> The way these points are interpreted depends on what mode has be set up
with one of the calls <i>bgnpoint,</i> bgnline, bgnclosedline or bgnpolygon. The
<i>bgnpoint</i> call specifies that the next series of vertex calls are specifying
a chain of points (dots) to be drawn. A  <i>bgnpoint</i> is terminated with a <i>endpoint</i>
call. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine bgnpoint
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;bgnpoint()
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine endpoint
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;endpoint()
</pre>
<p> The <i>bgnline</i> call specifies that the next series of vertex calls are specifying
the points on a polyline. A <i>bgnline</i>  is terminated with a<br>
 <i>endline</i>  call. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine bgnline
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;bgnline()
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine endline
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;endline()
</pre>
<p> The  <i>bgnclosedline</i> call is similar to the <i>bgnline</i> except that when  <i>endclosedline</i>
is called the first point given (ie. the one first after the bgnclosedline
call) is joined to the last point given (ie. the one just before the endclosedline
call). <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine bgncloseline
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;bgnclosedline()
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine endclosedline
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;endclosedline()
</pre>
<p> The <i>bgnpolygon</i> call specifies that the next series of vertex calls are
defining a polygon. When <i>endpolygon</i> is called, the polygon is closed and
filled (or drawn as an outline depending on the mode that has been set
with the  <i>polymode</i>  call if this call has been compilied into the library.

<p> <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine bgnpolygon
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;bgnpolygon()
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine endpolygon
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;endpolygon()
</pre>
<h3><a name='sect18' href='#toc18'>Arcs and Circles.</a></h3>
<p>
There are variations on all these routines that end in
&rsquo;s&rsquo; and also end in &rsquo;i&rsquo;. In the case of the &rsquo;s&rsquo; variations they take arguments
of type Scoord in C and integer*2 in FORTRAN. In the case of the &rsquo;i&rsquo; variations
they take arguments of type Icoord in C and integer in FORTRAN. 
<dl>

<dt><a href='circleprecision.nsegs.html'><a href='circleprecision.nsegs.html'><i>circleprecision(nsegs)</i></a>
</a>

</dt>
<dd>Set the number of line segments making up a circle. Default is currently
32. The number of segments in an arc is calculated from nsegs according
the span of the arc. This routine is only available in VOGL. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine circleprecision(nsegs)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer<tt> </tt>&nbsp;<tt> </tt>&nbsp;nsegs
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;circleprecision(nsegs)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;int<tt> </tt>&nbsp;<tt> </tt>&nbsp;nsegs;
</pre></dd>

<dt><i>arc(x,</i> y, radius, startang, endang) </dt>
<dd>Draw an arc. x, y, and radius are values
in world units. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine arc(x, y, radius, startang, endang)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x, y, radius;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer startang, endang;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;arc(x, y, radius, startang, endang)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord  x, y, radius;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Angle  startang, endang;
</pre></dd>

<dt><i>arcf(x,</i> y, radius, startang, endang) </dt>
<dd>Draw a filled arc. x, y, and radius
are values in world units. (How the filling is done may be changed by calling
 <i>polymode</i> , if this call has been compilied into the library). <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine arcf(x, y, radius, startang, endang)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x, y, radius;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer startang, endang;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;arcf(x, y, radius, startang, endang)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord  x, y, radius;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Angle  startang, endang;
</pre></dd>

<dt><i>circ(x,</i> y, radius) </dt>
<dd>Draw a circle. x, y, and radius are values in world units.
 <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine circ(x, y, radius)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y, radius
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;circ(x, y, radius)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y, radius;
</pre></dd>

<dt><i>circf(x,</i> y, radius) </dt>
<dd>Draw a filled circle. x, y, and radius are values in
world units.  How the filling is done may be changed by calling <i>polymode.</i>
<br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine circf(x, y, radius)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y, radius
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;circf(x, y, radius)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y, radius;
</pre></dd>
</dl>

<h3><a name='sect19' href='#toc19'>Curve Routines.</a></h3>

<dl>

<dt><i>curvebasis(id)</i> </dt>
<dd>Set the basis matrix for a curve to the matrix
referenced by id. The matrix and it&rsquo;s id are tied together with a call to
<i>defbasis.</i> <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran: 
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine curvebasis(id)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer id
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;curvebasis(id)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;short<tt> </tt>&nbsp;<tt> </tt>&nbsp;id;
</pre></dd>

<dt><a href='curveprecision.nsegs.html'><a href='curveprecision.nsegs.html'><i>curveprecision(nsegs)</i></a>
</a>
 </dt>
<dd>Define the number of line segments used to draw a
curve. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran: 
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine curveprecision(nsegs)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer nsegs
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;curveprecision(nsegs)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;short<tt> </tt>&nbsp;<tt> </tt>&nbsp;nsegs;
</pre></dd>

<dt><i>rcrv(geom)</i> </dt>
<dd>Draw a rational curve. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran: 
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine rcrv(geom)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real geom(4,4)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;rcrv(geom)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;geom[4][4];
</pre></dd>

<dt><i>rcrvn(n,</i> geom) </dt>
<dd>Draw n - 3 rational curve segments. Note: n must be at least
4. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran: 
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine rcrvn(n, geom)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real geom(4,n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;rcrvn(n, geom)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;geom[][4];
</pre></dd>

<dt><i>crv(geom)</i> </dt>
<dd>Draw a curve. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran: 
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine crv(geom)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real geom(3,4)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;crv(geom)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;geom[4][3];
</pre></dd>

<dt><i>crvn(n,</i> geom) </dt>
<dd>Draw n - 3 curve segments. Note: n must be at least 4. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran: 
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine crvn(n, geom)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real geom(3,n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;crvn(n, geom)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;geom[][3];
</pre></dd>

<dt><a href='curveit.n.html'><a href='curveit.n.html'><i>curveit(n)</i></a>
</a>
 </dt>
<dd>Draw a curve segment by iterating the top matrix in the matrix
stack as a forward difference matrix. This performs &rsquo;n&rsquo; iterations. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran: 
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine curveit(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;curveit(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;short<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
</pre></dd>
</dl>

<h3><a name='sect20' href='#toc20'>Rectangles and General Polygon Routines.</a></h3>
<p>
See also  <i>Vertex</i> calls above. The
way in which filled polygons (including circles and arcs) are treated depends
on the mode that has been set with the  <i>polymode</i> call. <p>
There are variations
on all these routines that end in &rsquo;s&rsquo; and also end in &rsquo;i&rsquo;. In the case of the
&rsquo;s&rsquo; variations they take arguments of type Scoord in C and integer*2 in FORTRAN.
In the case of the &rsquo;i&rsquo; variations they take arguments of type Icoord in C
and integer in FORTRAN. 
<dl>

<dt><i>rect(x1,</i> y1, x2, y2) </dt>
<dd>Draw a rectangle.  <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine rect(x1, y1, x2, y2)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x1, y1, x1, y2
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;rect(x1, y1, x2, y2)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x1, y1, x2, y2;
</pre></dd>

<dt><i>rectf(x1,</i> y1, x2, y2) </dt>
<dd>Draw a filled rectangle. (How the filling is done
may be changed by calling <i>polymode</i> , if this call has been compilied into
the library). <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine rectf(x1, y1, x2, y2)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x1, y1, x1, y2
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;rectf(x1, y1, x2, y2)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x1, y1, x2, y2;
</pre></dd>

<dt><i>poly2(n,</i> points) </dt>
<dd>Construct a (x, y) polygon from an array of points provided
by the user. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine poly2(n, points)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real points(2, n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;poly2(n, points)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;points[][2];
</pre></dd>

<dt><i>polf2(n,</i> points) </dt>
<dd>Construct a filled (x, y) polygon from an array of points
provided by the user. (How the filling is done may be changed by calling
<i>polymode</i> , if this call has been compilied into the library). <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine polf2(n, points)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real points(2, n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;polf2(n,  points)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;points[][2];
</pre></dd>

<dt><i>poly(n,</i> points) </dt>
<dd>Construct a polygon from an array of points provided by
the user. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine poly(n, points)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real points(3, n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;poly(n,  points)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;float<tt> </tt>&nbsp;<tt> </tt>&nbsp;points[][3];
</pre></dd>

<dt><i>polf(n,</i> points) </dt>
<dd>Construct a filled polygon from an array of points provided
by the user. (How the filling is done may be changed by calling <i>polymode</i>
, if this call has been compilied into the library). <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine polf(n, points)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real points(3, n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;polf(n, points)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;points[][3];
</pre></dd>

<dt><a href='backface.onoff.html'><a href='backface.onoff.html'><i>backface(onoff)</i></a>
</a>
 </dt>
<dd>Turns on culling of backfacing polygons. A polygon is backfacing
if it&rsquo;s orientation in *screen* coords is clockwise. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine backface(onoff)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;logical onoff
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;backface(onoff)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Boolean<tt> </tt>&nbsp;<tt> </tt>&nbsp;onoff;
</pre></dd>

<dt><a href='frontface.onoff.html'><a href='frontface.onoff.html'><i>frontface(onoff)</i></a>
</a>
 </dt>
<dd>Turns on culling of frontfacing polygons. A polygon is
frontfacing if it&rsquo;s orientation in *screen* coords is anticlockwise. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine frontface(clockwise)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;logical onoff
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;frontface(clockwise)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Boolean<tt> </tt>&nbsp;<tt> </tt>&nbsp;onoff;
</pre></dd>
</dl>

<h3><a name='sect21' href='#toc21'>Text routines.</a></h3>
The original VOGLE hardware fonts "small" and "large" have
the font numbers 0 and 1 respectively. The default font is 0. For X11 displays
the default fonts used by the program can be overridden by placing the
following defaults in the ~/.Xdefaults file: <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;vogl.smallfont: &lt;font name&gt;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;vogl.largefont: &lt;font name&gt;
</pre>
<dl>

<dt><i>font(fontid)</i> </dt>
<dd>Set the current font <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine font(fontid)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer fontid;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;font(fontid)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;short<tt> </tt>&nbsp;<tt> </tt>&nbsp;fontid;
</pre></dd>

<dt><i>cmov(x,</i> y, z) </dt>
<dd>Change the current character position. The usual variations
with the extensions &rsquo;i&rsquo; and &rsquo;s&rsquo; also apply here. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine cmov(x, y, z)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x, y, z;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;cmov(x, y, z)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y, z;
</pre></dd>

<dt><i>cmov2(x,</i> y) </dt>
<dd>Change the current character position in x and y. The usual
variations with the extensions &rsquo;i&rsquo; and &rsquo;s&rsquo; also apply here. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine cmov2(x, y)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x, y;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;cmov2(x, y)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y;
</pre></dd>

<dt><i>getheight()</i> </dt>
<dd>Return the maximum height in the current font. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer function getheight
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;getheight()
</pre></dd>

<dt><i>getwidth()</i> </dt>
<dd>Return the maximum width in the current font. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer function getwidth
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;getwidth()
</pre></dd>

<dt><i>strwidth(s)</i> </dt>
<dd>Return the length of the string s in screen coords. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer function strwidth(s, n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;character *(*) s
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;strwidth(s)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;char<tt> </tt>&nbsp;<tt> </tt>&nbsp;*s;
</pre></dd>

<dt><i>charstr(str)</i> </dt>
<dd>Draw the text in string at the current position. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine charst(str, len)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;character*(*) str
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer len
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:    
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;charstr(str)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;char *str;
</pre></dd>
</dl>

<h3><a name='sect22' href='#toc22'>Transformations Routines.</a></h3>
<p>
All transformations are cumulative, so if you rotate
something and then do a translate you are translating relative to the rotated
axes. If you need to preserve the current transformation matrix use pushmatrix(),
do the drawing, and then call popmatrix() to get back where you were before.

<dl>

<dt><i>translate(x,</i> y, z) </dt>
<dd>Set up a translation.  <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine translate(x, y, z)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x, y, z
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;translate(x, y, z)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y, z;
</pre></dd>

<dt><i>scale(x,</i> y, z) </dt>
<dd>Set up scaling factors in x, y, and z axis. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine scale(x, y, z)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x, y, z
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;scale(x, y, z)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y, z;
</pre></dd>

<dt><i>rot(angle,</i> axis) </dt>
<dd>Set up a rotation in axis axis. Axis is one of &rsquo;x&rsquo;, &rsquo;y&rsquo;, or
&rsquo;z&rsquo;. The angle in this case is a real number in degrees. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine rot(angle, axis)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real angle
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;character axis
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;rot(angle, axis)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;float<tt> </tt>&nbsp;<tt> </tt>&nbsp;angle;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;char<tt> </tt>&nbsp;<tt> </tt>&nbsp;axis;
</pre></dd>

<dt><i>rotate(angle,</i> axis) </dt>
<dd>Set up a rotation in axis axis. Axis is one of &rsquo;x&rsquo;, &rsquo;y&rsquo;,
or &rsquo;z&rsquo;, and the angle is in tenths of degrees. Makes you feel sentimental
doesn&rsquo;t it. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine rotate(angle, axis)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer angle
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;character axis
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;rotate(angle, axis)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Angle<tt> </tt>&nbsp;<tt> </tt>&nbsp;angle;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;char<tt> </tt>&nbsp;<tt> </tt>&nbsp;axis;
</pre></dd>
</dl>

<h3><a name='sect23' href='#toc23'>Patch Routines.</a></h3>

<dl>

<dt><i>patchbasis(tbasisid,</i> ubasisid) </dt>
<dd>Define the t and u basis matrix
id&rsquo;s of a patch. It is assumed that tbasisid and ubasisid have matrices associated
with them already (this is done using the <i>defbasis</i> call). <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine patchbasis(tid, uid)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer tid, uid
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;patchbasis(tid, ubid)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long<tt> </tt>&nbsp;<tt> </tt>&nbsp;tid, uid
</pre></dd>

<dt><i>patchprecision(tseg,</i> useg) </dt>
<dd>Set the minimum number of line segments making
up curves in a patch. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine patchprecision(tseg, useg)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer tseg, useg
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;patchprecision(tseg, useg)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long     tseg, useg;
</pre></dd>

<dt><i>patchcurves(nt,</i> nu) </dt>
<dd>Set the number of curves making up a patch. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine patchcurves(nt, nu)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer nt, nu
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;patchcurves(nt, nu)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;long     nt, nu;
</pre></dd>

<dt><i>rpatch(gx,</i> gy, gz, gw) </dt>
<dd>Draws a rational patch in the current basis, according
to the geometry matrices gx, gy, gz, and gw. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine rpatch(gx, gy, gz, gw)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real  gx(4,4), gy(4,4), gz(4,4), gw(4,4)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;rpatch(gx, gy, gz, gw)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    Matrix  gx, gy, gz, gw;
</pre></dd>

<dt><i>patch(gx,</i> gy, gz) </dt>
<dd>Draws a patch in the current basis, according to the
geometry matrices gx, gy, and gz. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine patch(gx, gy, gz)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real  gx(4,4), gy(4,4), gz(4,4)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;patch(gx, gy, gz)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Matrix  gx, gy, gz;
</pre></dd>
</dl>

<h3><a name='sect24' href='#toc24'>Point Routines.</a></h3>
<p>
There are variations on all these routines that end in &rsquo;s&rsquo;
and also end in &rsquo;i&rsquo;. In the case of the &rsquo;s&rsquo; variations they take arguments of
type Scoord in C and integer*2 in FORTRAN. In the case of the &rsquo;i&rsquo; variations
they take arguments of type Icoord in C and integer in FORTRAN. 
<dl>

<dt><i>pnt(x,</i> y,
z) </dt>
<dd>Draw a point at x, y, z <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine pnt(x, y, z)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x, y, z
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;pnt(x, y, z)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y, z;
</pre></dd>

<dt><i>pnt2(x,</i> y) </dt>
<dd>Draw a point at x, y. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine pnt2(x, y)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x, y
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;pnt2(x, y)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord<tt> </tt>&nbsp;<tt> </tt>&nbsp;x, y;
</pre></dd>
</dl>

<h3><a name='sect25' href='#toc25'>Object Routines.</a></h3>
<p>
Objects are graphical entities created by the drawing routines
called between <i>makeobj</i> and <i>closeobj.</i> Objects may be called from within other
objects. When an object is created most of the calculations required by
the drawing routines called within it are done up to where the calculations
involve the current transformation matrix. So if you need to draw the same
thing several times on the screen but in different places it is faster
to use objects than to call the appropriate drawing routines each time.

<dl>

<dt><a href='makeobj.n.html'><a href='makeobj.n.html'><i>makeobj(n)</i></a>
</a>
 </dt>
<dd>Commence the object number n. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine makeobj(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;makeobj(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Object<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
</pre></dd>

<dt><i>closeobj()</i> </dt>
<dd>Close the current object. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine closeobj()
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;closeobj()
</pre></dd>

<dt><i>genobj()</i> </dt>
<dd>Returns a unique object identifier. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer function genobj()
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Object
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;genobj()
</pre></dd>

<dt><i>getopenobj()</i> </dt>
<dd>Return the number of the current object. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer function getopenobj()
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Object
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;getopenobj()
</pre></dd>

<dt><a href='callobj.n.html'><a href='callobj.n.html'><i>callobj(n)</i></a>
</a>
 </dt>
<dd>Draw object number n. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine callobj(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;callobj(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Object<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
</pre></dd>

<dt><a href='isobj.n.html'><a href='isobj.n.html'><i>isobj(n)</i></a>
</a>
 </dt>
<dd>Returns non-zero if there is an object of number n. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;logical function isobj(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Boolean
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;isobj(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Object<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
</pre></dd>

<dt><a href='delobj.n.html'><a href='delobj.n.html'><i>delobj(n)</i></a>
</a>
 </dt>
<dd>Delete the object number n. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine delobj(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;delobj(n)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Object<tt> </tt>&nbsp;<tt> </tt>&nbsp;n;
</pre></dd>
</dl>

<h3><a name='sect26' href='#toc26'>Double Buffering.</a></h3>
Where possible VOGL allows for front and back buffers to
enable things like animation and smooth updating of the screen. Note: it
isn&rsquo;t possible to have backbuffer and frontbuffer true at the same time.

<dl>

<dt><i>gconfig</i> </dt>
<dd>With Iris GL you must call gconfig for things like doublebuffering
to take effect. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine gconfig
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;gconfig()
</pre></dd>

<dt><i>doublebuffer</i> </dt>
<dd>Flags our intention to do double buffering. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine doublebuffer
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;doublebuffer()
</pre></dd>

<dt><i>singlebuffer</i> </dt>
<dd>Switch back to singlebuffer mode. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine singlebuffer
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;singlebuffer()
</pre></dd>

<dt><i>backbuffer(Boolean)</i> </dt>
<dd>Make VOGL draw in the backbuffer. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine backbuffer(yesno)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;logical<tt> </tt>&nbsp;<tt> </tt>&nbsp;yesno;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;backbuffer(yesno)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Boolean<tt> </tt>&nbsp;<tt> </tt>&nbsp;yesno;
</pre></dd>

<dt><i>frontbuffer(Boolean)</i> </dt>
<dd>Make VOGL draw in the front buffer. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine frontbuffer(yesno)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;logical<tt> </tt>&nbsp;<tt> </tt>&nbsp;yesno;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;frontbuffer(yesno)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Boolean<tt> </tt>&nbsp;<tt> </tt>&nbsp;yesno;
</pre></dd>

<dt><i>swapbuffers()</i> </dt>
<dd>Swap the front and back buffers. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine swapbuffers
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;swapbuffers()
</pre></dd>
</dl>

<h3><a name='sect27' href='#toc27'>Position Routines.</a></h3>

<dl>

<dt><i>getgpos(x,</i> y, z, w) </dt>
<dd>Gets the current graphics position
in world coords. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine getgpos(x, y, z, w)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;real x, y, z
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;getgpos(x, y, z, w)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Coord *x, *y, *z, *w;
</pre></dd>

<dt><i>getcpos(ix,</i> iy) </dt>
<dd>Gets the current character position in screen coords. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;Fortran:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;subroutine getcpo(ix, iy)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;integer ix, iy
<tt> </tt>&nbsp;<tt> </tt>&nbsp;C:
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;getcpos(ix, iy)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Scoord *ix, *iy;
</pre></dd>
</dl>

<h2><a name='sect28' href='#toc28'>Bugs</a></h2>
<p>
Double buffering isn&rsquo;t supported on all devices. <p>
The yobbarays may be
turned on or they may be turned off. <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Description</a></li>
<ul>
<li><a name='toc2' href='#sect2'>Include files.</a></li>
<li><a name='toc3' href='#sect3'>Using X toolkits ans Sunview</a></li>
<li><a name='toc4' href='#sect4'>Device routines.</a></li>
<li><a name='toc5' href='#sect5'>Routines for controling flushing or syncronisation of the display.</a></li>
<li><a name='toc6' href='#sect6'>Routines For Setting Up Windows.</a></li>
<li><a name='toc7' href='#sect7'>General Routines.</a></li>
<li><a name='toc8' href='#sect8'>The Device Queue and Valuator Routines.</a></li>
<li><a name='toc9' href='#sect9'>Viewport Routines.</a></li>
<li><a name='toc10' href='#sect10'>Attribute Stack Routines.</a></li>
<li><a name='toc11' href='#sect11'>Projection Routines.</a></li>
<li><a name='toc12' href='#sect12'>window(left, right, bot, top, near, far)Specify a perspective viewing pyramid in world coordinates bygiving the rectangle closest to the eye (ie. at the near clippingplane) and the distances to the near and far clipping planes.                	Fortran:		subroutine window(left, right, bot, top, near, far)		real left, right, bot, top, near, far	C:    		window(left, right, bot, top, near, far)			float     left, right, bot, top, near, far;Matrix Stack Routines.</a></li>
<li><a name='toc13' href='#sect13'>Viewpoint Routines.</a></li>
<li><a name='toc14' href='#sect14'>Move Routines.</a></li>
<li><a name='toc15' href='#sect15'>Line routines.</a></li>
<li><a name='toc16' href='#sect16'>Drawing Routines.</a></li>
<li><a name='toc17' href='#sect17'>Vertex calls.</a></li>
<li><a name='toc18' href='#sect18'>Arcs and Circles.</a></li>
<li><a name='toc19' href='#sect19'>Curve Routines.</a></li>
<li><a name='toc20' href='#sect20'>Rectangles and General Polygon Routines.</a></li>
<li><a name='toc21' href='#sect21'>Text routines.</a></li>
<li><a name='toc22' href='#sect22'>Transformations Routines.</a></li>
<li><a name='toc23' href='#sect23'>Patch Routines.</a></li>
<li><a name='toc24' href='#sect24'>Point Routines.</a></li>
<li><a name='toc25' href='#sect25'>Object Routines.</a></li>
<li><a name='toc26' href='#sect26'>Double Buffering.</a></li>
<li><a name='toc27' href='#sect27'>Position Routines.</a></li>
</ul>
<li><a name='toc28' href='#sect28'>Bugs</a></li>
</ul>
</body>
</html>
