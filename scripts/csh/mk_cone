#! /bin/csh -f
#
# to get a rotating disk:    ./mk_cone vscale=1 outflow=0 cone=90 out=disk1
# or via tkrun:              tkrun ./mk_cone
#
# the disk= blends in a true disk so you can see both the outflow cones and the disk
# Make sure "ds9" has been launched before this script is run, as 5 frame are sent to ds9
#
#
#     nov-2018      written at ESO
#     jul-2020      expanded with a disk and indep. geometry for Alberto to play with
#     jun-2021      fix missing sign=; add noise

#   rmin:    the cone starts at rmin in the Z=0 plane
#   vscale   setting this > 0 will give the outflow some rotation as well
#   outflow  outflow
#   flow
#   view     0 = optically thin   1=only see front   (-1 only see back)
#   incd     inc of disk
#   inc      inc of cone w.r.t. disk (disk is always along X axis)
#   pa       pa of cone w.r.t. disk
#   mirror   1=have both sides
#   fill     t=cone is filled  f=cone is hollow
#   svar     smoothing
#   mass     this is the mass ratio of the disk to a half cone

set nbody   = 10000     #> SCALE nbody=10000  1000:1000000:1000
set rmin    = 0.3       #> SCALE rmin=0.3     0:1:0.1
set rmax    = 1         #> SCALE rmax=1       0:2:0.1
set vscale  = 0.9       #> SCALE vscale=0.9   -2:2:0.1
set outflow = 0.4       #> SCALE outflow=0.4  0:2:0.1
set flow    = flat      #> RADIO flow=flat    flat,rise,fall
set cone    = 30        #> SCALE cone=30      0:90:1
set inc     = 0         #> SCALE inc=0        0:90:1
set pa      = 0         #> SCALE pa=0         0:360:1
set view    = 0         #> RADIO view=0       -1,0,1
set incd    = 80        #> SCALE incd=80      0:90:1
set mirror  = 1         #> RADIO mirror=1     0,1
set fill    = f         #> RADIO fill=f       t,f
set disk    = 1         #> RADIO disk=1       0,1/1000,1/100,1/10,1,10,100,1000,10000
set svar    = 0.01      #> SCALE svar=0.01    0:1:0.01
set noise   = 0.0       #> SCALE noise=0.0    0:1:0.001
set out     = cone1     #> ENTRY out=cone1

#  parameters not in the GUI
set rmaxd = 2
set rc    = 0.1
set n     = 128
set scale = 1/60,1/60,100     # model units are arcmin, 100 km/s

foreach _arg ($*)
    set $_arg
end

# in Bae_2016_ApJ_828_97.pdf there is nice diagram (Figure 1+2) explaining their parameters.
# the main difference is that we only use "incd" for the disk, we don't rotate the disk
# so "pad=90" fixed really.
# The pa/inc of the cone is defined w.r.t. the disk, which can then be inclined after.
# Here are the variables from the paper:
#   i_bicone   (for the cone)
#   PA_bicone
#   i_dust     (for the disk)
#   PA_dust
#   theta_in   (half cone opening angle)
# they use 3 different velocity profiles:
#   - linear (which we have here)
#   - linear decrease (inverse of previous)
#   - constant


rm -f $out.*


# the disk rotates counterclock wise, kinematic major axis -X, and the near side is along the +Y axis.
mkdisk $out.0 $nbody mass=$disk potname=log potpars="0,0.5*$rc,$rc" rmax=$rmaxd >& /dev/null

if ($flow == flat) then
    echo 0 $outflow   > $out.flow
    echo 1 $outflow  >> $out.flow
else if ($flow == rise) then
    echo 0 0          > $out.flow
    echo 1 $outflow  >> $out.flow
else if ($flow == fall) then
    echo 0 $outflow   > $out.flow
    echo 1 0         >> $out.flow
else
    echo No valid $floa
    exit 0
endif    

if ($mirror == 0) then
  # only one cone
  mkdisk - $nbody mass=1 rmin=$rmin rmax=$rmax potname=log potpars="0,0.5*$rc,$rc" |\
    snapscale - - vscale=$vscale |\
    snapspin - - rotcur=$out.flow outflow=t sign=-1 |\
    snapfold - - theta=90-$cone fill=$fill view=$view |\
    snaprotate - $out.1 $inc,$pa xz

    cat $out.0 $out.1 |\
    snapmerge - - |\
    snaprotate - - $incd x > $out.snap
else
  # one cone on each side
  mkdisk - $nbody mass=1 rmin=$rmin rmax=$rmax potname=log potpars="0,0.5*$rc,$rc" |\
    snapscale - - vscale=$vscale |\
    snapspin - - rotcur=$out.flow outflow=t sign=-1 |\
    snapfold - - theta=90-$cone fill=$fill view=$view |\
    snapshift - - 0,0,-$rmin |\
    snaprotate - $out.1 $inc,$pa xz    
  mkdisk - $nbody mass=1 rmin=$rmin rmax=$rmax potname=log potpars="0,0.5*$rc,$rc" |\
    snapscale - - vscale=$vscale |\
    snapspin - - rotcur=$out.flow outflow=t sign=1 |\
    snapfold - - theta=90-$cone fill=$fill view=$view |\
    snapshift - - 0,0,-$rmin |\
    snapscale - - rscale=1,1,-1 |\
    snaprotate - $out.2 $inc,$pa xz    

  cat $out.0 $out.1 $out.2 |\
    snapmerge - - |\
    snaprotate - - $incd x > $out.snap
endif

#   svar: add a bit of smoothing.   In these defaults pixelsize=4/128 = 0.03
snapgrid $out.snap $out.vel moment=-1 nx=$n ny=$n svar=$svar >& /dev/null
snapgrid $out.snap $out.den moment=0  nx=$n ny=$n svar=$svar >& /dev/null
snapgrid $out.snap $out.sig moment=-2 nx=$n ny=$n svar=$svar >& /dev/null
ccdfits $out.den $out.den.fits scale=$scale radecvel=t >& /dev/null
ccdfits $out.vel $out.vel.fits scale=$scale radecvel=t >& /dev/null
ccdfits $out.sig $out.sig.fits scale=$scale radecvel=t >& /dev/null

snapgrid $out.snap - nx=$n ny=$n nz=$n/2 zrange=-2:2 |\
   ccdmath - - "%1+rang(0,$noise)" |\
   ccdsmooth - - gauss=$svar |\
   ccdfits - $out.fits scale=$scale radecvel=t debug=-1

xpaset -p ds9 frame frameno 1
nds9 $out.vel.fits
xpaset -p ds9 frame frameno 2
nds9 $out.den.fits
xpaset -p ds9 frame frameno 3
nds9 $out.sig.fits

#  load the same cube 3 times, so locally you will need to Cube -> Axis Order -> 1,2,3  1,3,2 and 2,3,1
#  to get the different types of PP or PV slices
xpaset -p ds9 frame frameno 4
nds9 $out.fits
xpaset -p ds9 frame frameno 5
nds9 $out.fits
xpaset -p ds9 frame frameno 6
nds9 $out.fits

#   example of a R-V diagram along the major and minor axis.
#   the far side is at pa=180, the kin. major at 90.
if (1) then
  fitsccd $out.fits - | rvstack - $out.rvma.ccd pa=90     inc=$incd vsys=0 center=$n/2,$n/2 rscale=3600 mode=r
  xpaset -p ds9 frame frameno 7
  nds9 $out.rvma.ccd

  fitsccd $out.fits - | rvstack - $out.rvmi.ccd pa=90+90  inc=$incd vsys=0 center=$n/2,$n/2 rscale=3600 mode=o
  xpaset -p ds9 frame frameno 8
  nds9 $out.rvmi.ccd
endif

